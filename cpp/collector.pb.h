// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: collector.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_collector_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_collector_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_collector_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_collector_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_collector_2eproto;
namespace collector {
class Aws;
struct AwsDefaultTypeInternal;
extern AwsDefaultTypeInternal _Aws_default_instance_;
class Azure;
struct AzureDefaultTypeInternal;
extern AzureDefaultTypeInternal _Azure_default_instance_;
class HostID;
struct HostIDDefaultTypeInternal;
extern HostIDDefaultTypeInternal _HostID_default_instance_;
class K8s;
struct K8sDefaultTypeInternal;
extern K8sDefaultTypeInternal _K8s_default_instance_;
class MessageRequest;
struct MessageRequestDefaultTypeInternal;
extern MessageRequestDefaultTypeInternal _MessageRequest_default_instance_;
class MessageResult;
struct MessageResultDefaultTypeInternal;
extern MessageResultDefaultTypeInternal _MessageResult_default_instance_;
class OboeSetting;
struct OboeSettingDefaultTypeInternal;
extern OboeSettingDefaultTypeInternal _OboeSetting_default_instance_;
class OboeSetting_ArgumentsEntry_DoNotUse;
struct OboeSetting_ArgumentsEntry_DoNotUseDefaultTypeInternal;
extern OboeSetting_ArgumentsEntry_DoNotUseDefaultTypeInternal _OboeSetting_ArgumentsEntry_DoNotUse_default_instance_;
class PingRequest;
struct PingRequestDefaultTypeInternal;
extern PingRequestDefaultTypeInternal _PingRequest_default_instance_;
class SettingsRequest;
struct SettingsRequestDefaultTypeInternal;
extern SettingsRequestDefaultTypeInternal _SettingsRequest_default_instance_;
class SettingsResult;
struct SettingsResultDefaultTypeInternal;
extern SettingsResultDefaultTypeInternal _SettingsResult_default_instance_;
}  // namespace collector
PROTOBUF_NAMESPACE_OPEN
template<> ::collector::Aws* Arena::CreateMaybeMessage<::collector::Aws>(Arena*);
template<> ::collector::Azure* Arena::CreateMaybeMessage<::collector::Azure>(Arena*);
template<> ::collector::HostID* Arena::CreateMaybeMessage<::collector::HostID>(Arena*);
template<> ::collector::K8s* Arena::CreateMaybeMessage<::collector::K8s>(Arena*);
template<> ::collector::MessageRequest* Arena::CreateMaybeMessage<::collector::MessageRequest>(Arena*);
template<> ::collector::MessageResult* Arena::CreateMaybeMessage<::collector::MessageResult>(Arena*);
template<> ::collector::OboeSetting* Arena::CreateMaybeMessage<::collector::OboeSetting>(Arena*);
template<> ::collector::OboeSetting_ArgumentsEntry_DoNotUse* Arena::CreateMaybeMessage<::collector::OboeSetting_ArgumentsEntry_DoNotUse>(Arena*);
template<> ::collector::PingRequest* Arena::CreateMaybeMessage<::collector::PingRequest>(Arena*);
template<> ::collector::SettingsRequest* Arena::CreateMaybeMessage<::collector::SettingsRequest>(Arena*);
template<> ::collector::SettingsResult* Arena::CreateMaybeMessage<::collector::SettingsResult>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace collector {

enum ResultCode : int {
  OK = 0,
  TRY_LATER = 1,
  INVALID_API_KEY = 2,
  LIMIT_EXCEEDED = 3,
  REDIRECT = 4,
  ResultCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ResultCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ResultCode_IsValid(int value);
constexpr ResultCode ResultCode_MIN = OK;
constexpr ResultCode ResultCode_MAX = REDIRECT;
constexpr int ResultCode_ARRAYSIZE = ResultCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResultCode_descriptor();
template<typename T>
inline const std::string& ResultCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResultCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResultCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResultCode_descriptor(), enum_t_value);
}
inline bool ResultCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResultCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResultCode>(
    ResultCode_descriptor(), name, value);
}
enum EncodingType : int {
  BSON = 0,
  PROTOBUF = 1,
  EncodingType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EncodingType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EncodingType_IsValid(int value);
constexpr EncodingType EncodingType_MIN = BSON;
constexpr EncodingType EncodingType_MAX = PROTOBUF;
constexpr int EncodingType_ARRAYSIZE = EncodingType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EncodingType_descriptor();
template<typename T>
inline const std::string& EncodingType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EncodingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EncodingType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EncodingType_descriptor(), enum_t_value);
}
inline bool EncodingType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EncodingType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EncodingType>(
    EncodingType_descriptor(), name, value);
}
enum HostType : int {
  PERSISTENT = 0,
  AWS_LAMBDA = 1,
  HostType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  HostType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool HostType_IsValid(int value);
constexpr HostType HostType_MIN = PERSISTENT;
constexpr HostType HostType_MAX = AWS_LAMBDA;
constexpr int HostType_ARRAYSIZE = HostType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HostType_descriptor();
template<typename T>
inline const std::string& HostType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HostType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HostType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HostType_descriptor(), enum_t_value);
}
inline bool HostType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HostType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HostType>(
    HostType_descriptor(), name, value);
}
enum OboeSettingType : int {
  DEFAULT_SAMPLE_RATE = 0,
  LAYER_SAMPLE_RATE = 1,
  LAYER_APP_SAMPLE_RATE = 2,
  LAYER_HTTPHOST_SAMPLE_RATE = 3,
  CONFIG_STRING = 4,
  CONFIG_INT = 5,
  OboeSettingType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  OboeSettingType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool OboeSettingType_IsValid(int value);
constexpr OboeSettingType OboeSettingType_MIN = DEFAULT_SAMPLE_RATE;
constexpr OboeSettingType OboeSettingType_MAX = CONFIG_INT;
constexpr int OboeSettingType_ARRAYSIZE = OboeSettingType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OboeSettingType_descriptor();
template<typename T>
inline const std::string& OboeSettingType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OboeSettingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OboeSettingType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OboeSettingType_descriptor(), enum_t_value);
}
inline bool OboeSettingType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OboeSettingType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OboeSettingType>(
    OboeSettingType_descriptor(), name, value);
}
// ===================================================================

class Aws final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:collector.Aws) */ {
 public:
  inline Aws() : Aws(nullptr) {}
  ~Aws() override;
  explicit PROTOBUF_CONSTEXPR Aws(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Aws(const Aws& from);
  Aws(Aws&& from) noexcept
    : Aws() {
    *this = ::std::move(from);
  }

  inline Aws& operator=(const Aws& from) {
    CopyFrom(from);
    return *this;
  }
  inline Aws& operator=(Aws&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Aws& default_instance() {
    return *internal_default_instance();
  }
  static inline const Aws* internal_default_instance() {
    return reinterpret_cast<const Aws*>(
               &_Aws_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Aws& a, Aws& b) {
    a.Swap(&b);
  }
  inline void Swap(Aws* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Aws* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Aws* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Aws>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Aws& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Aws& from) {
    Aws::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Aws* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "collector.Aws";
  }
  protected:
  explicit Aws(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCloudProviderFieldNumber = 1,
    kCloudPlatformFieldNumber = 2,
    kCloudAccountIdFieldNumber = 3,
    kCloudRegionFieldNumber = 4,
    kCloudAvailabilityZoneFieldNumber = 5,
    kHostIdFieldNumber = 6,
    kHostImageIdFieldNumber = 7,
    kHostNameFieldNumber = 8,
    kHostTypeFieldNumber = 9,
  };
  // string cloudProvider = 1;
  void clear_cloudprovider();
  const std::string& cloudprovider() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cloudprovider(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cloudprovider();
  PROTOBUF_NODISCARD std::string* release_cloudprovider();
  void set_allocated_cloudprovider(std::string* cloudprovider);
  private:
  const std::string& _internal_cloudprovider() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cloudprovider(const std::string& value);
  std::string* _internal_mutable_cloudprovider();
  public:

  // string cloudPlatform = 2;
  void clear_cloudplatform();
  const std::string& cloudplatform() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cloudplatform(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cloudplatform();
  PROTOBUF_NODISCARD std::string* release_cloudplatform();
  void set_allocated_cloudplatform(std::string* cloudplatform);
  private:
  const std::string& _internal_cloudplatform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cloudplatform(const std::string& value);
  std::string* _internal_mutable_cloudplatform();
  public:

  // string cloudAccountId = 3;
  void clear_cloudaccountid();
  const std::string& cloudaccountid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cloudaccountid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cloudaccountid();
  PROTOBUF_NODISCARD std::string* release_cloudaccountid();
  void set_allocated_cloudaccountid(std::string* cloudaccountid);
  private:
  const std::string& _internal_cloudaccountid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cloudaccountid(const std::string& value);
  std::string* _internal_mutable_cloudaccountid();
  public:

  // string cloudRegion = 4;
  void clear_cloudregion();
  const std::string& cloudregion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cloudregion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cloudregion();
  PROTOBUF_NODISCARD std::string* release_cloudregion();
  void set_allocated_cloudregion(std::string* cloudregion);
  private:
  const std::string& _internal_cloudregion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cloudregion(const std::string& value);
  std::string* _internal_mutable_cloudregion();
  public:

  // string cloudAvailabilityZone = 5;
  void clear_cloudavailabilityzone();
  const std::string& cloudavailabilityzone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cloudavailabilityzone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cloudavailabilityzone();
  PROTOBUF_NODISCARD std::string* release_cloudavailabilityzone();
  void set_allocated_cloudavailabilityzone(std::string* cloudavailabilityzone);
  private:
  const std::string& _internal_cloudavailabilityzone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cloudavailabilityzone(const std::string& value);
  std::string* _internal_mutable_cloudavailabilityzone();
  public:

  // string hostId = 6;
  void clear_hostid();
  const std::string& hostid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostid();
  PROTOBUF_NODISCARD std::string* release_hostid();
  void set_allocated_hostid(std::string* hostid);
  private:
  const std::string& _internal_hostid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostid(const std::string& value);
  std::string* _internal_mutable_hostid();
  public:

  // string hostImageId = 7;
  void clear_hostimageid();
  const std::string& hostimageid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostimageid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostimageid();
  PROTOBUF_NODISCARD std::string* release_hostimageid();
  void set_allocated_hostimageid(std::string* hostimageid);
  private:
  const std::string& _internal_hostimageid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostimageid(const std::string& value);
  std::string* _internal_mutable_hostimageid();
  public:

  // string hostName = 8;
  void clear_hostname();
  const std::string& hostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // string hostType = 9;
  void clear_hosttype();
  const std::string& hosttype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hosttype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hosttype();
  PROTOBUF_NODISCARD std::string* release_hosttype();
  void set_allocated_hosttype(std::string* hosttype);
  private:
  const std::string& _internal_hosttype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hosttype(const std::string& value);
  std::string* _internal_mutable_hosttype();
  public:

  // @@protoc_insertion_point(class_scope:collector.Aws)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cloudprovider_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cloudplatform_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cloudaccountid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cloudregion_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cloudavailabilityzone_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostimageid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hosttype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collector_2eproto;
};
// -------------------------------------------------------------------

class Azure final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:collector.Azure) */ {
 public:
  inline Azure() : Azure(nullptr) {}
  ~Azure() override;
  explicit PROTOBUF_CONSTEXPR Azure(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Azure(const Azure& from);
  Azure(Azure&& from) noexcept
    : Azure() {
    *this = ::std::move(from);
  }

  inline Azure& operator=(const Azure& from) {
    CopyFrom(from);
    return *this;
  }
  inline Azure& operator=(Azure&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Azure& default_instance() {
    return *internal_default_instance();
  }
  static inline const Azure* internal_default_instance() {
    return reinterpret_cast<const Azure*>(
               &_Azure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Azure& a, Azure& b) {
    a.Swap(&b);
  }
  inline void Swap(Azure* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Azure* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Azure* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Azure>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Azure& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Azure& from) {
    Azure::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Azure* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "collector.Azure";
  }
  protected:
  explicit Azure(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCloudProviderFieldNumber = 1,
    kCloudPlatformFieldNumber = 2,
    kCloudRegionFieldNumber = 3,
    kCloudAccountIdFieldNumber = 4,
    kHostIdFieldNumber = 5,
    kHostNameFieldNumber = 6,
    kAzureVmNameFieldNumber = 7,
    kAzureVmSizeFieldNumber = 8,
    kAzureVmScaleSetNameFieldNumber = 9,
    kAzureResourceGroupNameFieldNumber = 10,
  };
  // string cloudProvider = 1;
  void clear_cloudprovider();
  const std::string& cloudprovider() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cloudprovider(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cloudprovider();
  PROTOBUF_NODISCARD std::string* release_cloudprovider();
  void set_allocated_cloudprovider(std::string* cloudprovider);
  private:
  const std::string& _internal_cloudprovider() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cloudprovider(const std::string& value);
  std::string* _internal_mutable_cloudprovider();
  public:

  // string cloudPlatform = 2;
  void clear_cloudplatform();
  const std::string& cloudplatform() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cloudplatform(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cloudplatform();
  PROTOBUF_NODISCARD std::string* release_cloudplatform();
  void set_allocated_cloudplatform(std::string* cloudplatform);
  private:
  const std::string& _internal_cloudplatform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cloudplatform(const std::string& value);
  std::string* _internal_mutable_cloudplatform();
  public:

  // string cloudRegion = 3;
  void clear_cloudregion();
  const std::string& cloudregion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cloudregion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cloudregion();
  PROTOBUF_NODISCARD std::string* release_cloudregion();
  void set_allocated_cloudregion(std::string* cloudregion);
  private:
  const std::string& _internal_cloudregion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cloudregion(const std::string& value);
  std::string* _internal_mutable_cloudregion();
  public:

  // string cloudAccountId = 4;
  void clear_cloudaccountid();
  const std::string& cloudaccountid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cloudaccountid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cloudaccountid();
  PROTOBUF_NODISCARD std::string* release_cloudaccountid();
  void set_allocated_cloudaccountid(std::string* cloudaccountid);
  private:
  const std::string& _internal_cloudaccountid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cloudaccountid(const std::string& value);
  std::string* _internal_mutable_cloudaccountid();
  public:

  // string hostId = 5;
  void clear_hostid();
  const std::string& hostid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostid();
  PROTOBUF_NODISCARD std::string* release_hostid();
  void set_allocated_hostid(std::string* hostid);
  private:
  const std::string& _internal_hostid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostid(const std::string& value);
  std::string* _internal_mutable_hostid();
  public:

  // string hostName = 6;
  void clear_hostname();
  const std::string& hostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // string azureVmName = 7;
  void clear_azurevmname();
  const std::string& azurevmname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_azurevmname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_azurevmname();
  PROTOBUF_NODISCARD std::string* release_azurevmname();
  void set_allocated_azurevmname(std::string* azurevmname);
  private:
  const std::string& _internal_azurevmname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_azurevmname(const std::string& value);
  std::string* _internal_mutable_azurevmname();
  public:

  // string azureVmSize = 8;
  void clear_azurevmsize();
  const std::string& azurevmsize() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_azurevmsize(ArgT0&& arg0, ArgT... args);
  std::string* mutable_azurevmsize();
  PROTOBUF_NODISCARD std::string* release_azurevmsize();
  void set_allocated_azurevmsize(std::string* azurevmsize);
  private:
  const std::string& _internal_azurevmsize() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_azurevmsize(const std::string& value);
  std::string* _internal_mutable_azurevmsize();
  public:

  // string azureVmScaleSetName = 9;
  void clear_azurevmscalesetname();
  const std::string& azurevmscalesetname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_azurevmscalesetname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_azurevmscalesetname();
  PROTOBUF_NODISCARD std::string* release_azurevmscalesetname();
  void set_allocated_azurevmscalesetname(std::string* azurevmscalesetname);
  private:
  const std::string& _internal_azurevmscalesetname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_azurevmscalesetname(const std::string& value);
  std::string* _internal_mutable_azurevmscalesetname();
  public:

  // string azureResourceGroupName = 10;
  void clear_azureresourcegroupname();
  const std::string& azureresourcegroupname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_azureresourcegroupname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_azureresourcegroupname();
  PROTOBUF_NODISCARD std::string* release_azureresourcegroupname();
  void set_allocated_azureresourcegroupname(std::string* azureresourcegroupname);
  private:
  const std::string& _internal_azureresourcegroupname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_azureresourcegroupname(const std::string& value);
  std::string* _internal_mutable_azureresourcegroupname();
  public:

  // @@protoc_insertion_point(class_scope:collector.Azure)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cloudprovider_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cloudplatform_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cloudregion_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cloudaccountid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr azurevmname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr azurevmsize_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr azurevmscalesetname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr azureresourcegroupname_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collector_2eproto;
};
// -------------------------------------------------------------------

class K8s final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:collector.K8s) */ {
 public:
  inline K8s() : K8s(nullptr) {}
  ~K8s() override;
  explicit PROTOBUF_CONSTEXPR K8s(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  K8s(const K8s& from);
  K8s(K8s&& from) noexcept
    : K8s() {
    *this = ::std::move(from);
  }

  inline K8s& operator=(const K8s& from) {
    CopyFrom(from);
    return *this;
  }
  inline K8s& operator=(K8s&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const K8s& default_instance() {
    return *internal_default_instance();
  }
  static inline const K8s* internal_default_instance() {
    return reinterpret_cast<const K8s*>(
               &_K8s_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(K8s& a, K8s& b) {
    a.Swap(&b);
  }
  inline void Swap(K8s* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(K8s* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  K8s* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<K8s>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const K8s& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const K8s& from) {
    K8s::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(K8s* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "collector.K8s";
  }
  protected:
  explicit K8s(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespaceFieldNumber = 1,
    kPodNameFieldNumber = 2,
    kPodUidFieldNumber = 3,
    kContainerIdFieldNumber = 4,
  };
  // string namespace = 1;
  void clear_namespace_();
  const std::string& namespace_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_();
  PROTOBUF_NODISCARD std::string* release_namespace_();
  void set_allocated_namespace_(std::string* namespace_);
  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(const std::string& value);
  std::string* _internal_mutable_namespace_();
  public:

  // string podName = 2;
  void clear_podname();
  const std::string& podname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_podname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_podname();
  PROTOBUF_NODISCARD std::string* release_podname();
  void set_allocated_podname(std::string* podname);
  private:
  const std::string& _internal_podname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_podname(const std::string& value);
  std::string* _internal_mutable_podname();
  public:

  // string podUid = 3;
  void clear_poduid();
  const std::string& poduid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_poduid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_poduid();
  PROTOBUF_NODISCARD std::string* release_poduid();
  void set_allocated_poduid(std::string* poduid);
  private:
  const std::string& _internal_poduid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_poduid(const std::string& value);
  std::string* _internal_mutable_poduid();
  public:

  // string containerId = 4;
  void clear_containerid();
  const std::string& containerid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_containerid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_containerid();
  PROTOBUF_NODISCARD std::string* release_containerid();
  void set_allocated_containerid(std::string* containerid);
  private:
  const std::string& _internal_containerid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_containerid(const std::string& value);
  std::string* _internal_mutable_containerid();
  public:

  // @@protoc_insertion_point(class_scope:collector.K8s)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr podname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr poduid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr containerid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collector_2eproto;
};
// -------------------------------------------------------------------

class HostID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:collector.HostID) */ {
 public:
  inline HostID() : HostID(nullptr) {}
  ~HostID() override;
  explicit PROTOBUF_CONSTEXPR HostID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HostID(const HostID& from);
  HostID(HostID&& from) noexcept
    : HostID() {
    *this = ::std::move(from);
  }

  inline HostID& operator=(const HostID& from) {
    CopyFrom(from);
    return *this;
  }
  inline HostID& operator=(HostID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HostID& default_instance() {
    return *internal_default_instance();
  }
  static inline const HostID* internal_default_instance() {
    return reinterpret_cast<const HostID*>(
               &_HostID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(HostID& a, HostID& b) {
    a.Swap(&b);
  }
  inline void Swap(HostID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HostID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HostID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HostID>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HostID& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HostID& from) {
    HostID::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HostID* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "collector.HostID";
  }
  protected:
  explicit HostID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpAddressesFieldNumber = 2,
    kMacAddressesFieldNumber = 8,
    kHostnameFieldNumber = 1,
    kUuidFieldNumber = 3,
    kEc2InstanceIDFieldNumber = 5,
    kEc2AvailabilityZoneFieldNumber = 6,
    kDockerContainerIDFieldNumber = 7,
    kHerokuDynoIDFieldNumber = 9,
    kAzAppServiceInstanceIDFieldNumber = 10,
    kUamsClientIDFieldNumber = 12,
    kAwsMetadataFieldNumber = 13,
    kAzureMetadataFieldNumber = 14,
    kK8SMetadataFieldNumber = 15,
    kPidFieldNumber = 4,
    kHostTypeFieldNumber = 11,
  };
  // repeated string ip_addresses = 2;
  int ip_addresses_size() const;
  private:
  int _internal_ip_addresses_size() const;
  public:
  void clear_ip_addresses();
  const std::string& ip_addresses(int index) const;
  std::string* mutable_ip_addresses(int index);
  void set_ip_addresses(int index, const std::string& value);
  void set_ip_addresses(int index, std::string&& value);
  void set_ip_addresses(int index, const char* value);
  void set_ip_addresses(int index, const char* value, size_t size);
  std::string* add_ip_addresses();
  void add_ip_addresses(const std::string& value);
  void add_ip_addresses(std::string&& value);
  void add_ip_addresses(const char* value);
  void add_ip_addresses(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ip_addresses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ip_addresses();
  private:
  const std::string& _internal_ip_addresses(int index) const;
  std::string* _internal_add_ip_addresses();
  public:

  // repeated string macAddresses = 8;
  int macaddresses_size() const;
  private:
  int _internal_macaddresses_size() const;
  public:
  void clear_macaddresses();
  const std::string& macaddresses(int index) const;
  std::string* mutable_macaddresses(int index);
  void set_macaddresses(int index, const std::string& value);
  void set_macaddresses(int index, std::string&& value);
  void set_macaddresses(int index, const char* value);
  void set_macaddresses(int index, const char* value, size_t size);
  std::string* add_macaddresses();
  void add_macaddresses(const std::string& value);
  void add_macaddresses(std::string&& value);
  void add_macaddresses(const char* value);
  void add_macaddresses(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& macaddresses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_macaddresses();
  private:
  const std::string& _internal_macaddresses(int index) const;
  std::string* _internal_add_macaddresses();
  public:

  // string hostname = 1;
  void clear_hostname();
  const std::string& hostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // string uuid = 3;
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // string ec2InstanceID = 5;
  void clear_ec2instanceid();
  const std::string& ec2instanceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ec2instanceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ec2instanceid();
  PROTOBUF_NODISCARD std::string* release_ec2instanceid();
  void set_allocated_ec2instanceid(std::string* ec2instanceid);
  private:
  const std::string& _internal_ec2instanceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ec2instanceid(const std::string& value);
  std::string* _internal_mutable_ec2instanceid();
  public:

  // string ec2AvailabilityZone = 6;
  void clear_ec2availabilityzone();
  const std::string& ec2availabilityzone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ec2availabilityzone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ec2availabilityzone();
  PROTOBUF_NODISCARD std::string* release_ec2availabilityzone();
  void set_allocated_ec2availabilityzone(std::string* ec2availabilityzone);
  private:
  const std::string& _internal_ec2availabilityzone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ec2availabilityzone(const std::string& value);
  std::string* _internal_mutable_ec2availabilityzone();
  public:

  // string dockerContainerID = 7;
  void clear_dockercontainerid();
  const std::string& dockercontainerid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dockercontainerid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dockercontainerid();
  PROTOBUF_NODISCARD std::string* release_dockercontainerid();
  void set_allocated_dockercontainerid(std::string* dockercontainerid);
  private:
  const std::string& _internal_dockercontainerid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dockercontainerid(const std::string& value);
  std::string* _internal_mutable_dockercontainerid();
  public:

  // string herokuDynoID = 9;
  void clear_herokudynoid();
  const std::string& herokudynoid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_herokudynoid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_herokudynoid();
  PROTOBUF_NODISCARD std::string* release_herokudynoid();
  void set_allocated_herokudynoid(std::string* herokudynoid);
  private:
  const std::string& _internal_herokudynoid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_herokudynoid(const std::string& value);
  std::string* _internal_mutable_herokudynoid();
  public:

  // string azAppServiceInstanceID = 10;
  void clear_azappserviceinstanceid();
  const std::string& azappserviceinstanceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_azappserviceinstanceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_azappserviceinstanceid();
  PROTOBUF_NODISCARD std::string* release_azappserviceinstanceid();
  void set_allocated_azappserviceinstanceid(std::string* azappserviceinstanceid);
  private:
  const std::string& _internal_azappserviceinstanceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_azappserviceinstanceid(const std::string& value);
  std::string* _internal_mutable_azappserviceinstanceid();
  public:

  // string uamsClientID = 12;
  void clear_uamsclientid();
  const std::string& uamsclientid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uamsclientid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uamsclientid();
  PROTOBUF_NODISCARD std::string* release_uamsclientid();
  void set_allocated_uamsclientid(std::string* uamsclientid);
  private:
  const std::string& _internal_uamsclientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uamsclientid(const std::string& value);
  std::string* _internal_mutable_uamsclientid();
  public:

  // .collector.Aws awsMetadata = 13;
  bool has_awsmetadata() const;
  private:
  bool _internal_has_awsmetadata() const;
  public:
  void clear_awsmetadata();
  const ::collector::Aws& awsmetadata() const;
  PROTOBUF_NODISCARD ::collector::Aws* release_awsmetadata();
  ::collector::Aws* mutable_awsmetadata();
  void set_allocated_awsmetadata(::collector::Aws* awsmetadata);
  private:
  const ::collector::Aws& _internal_awsmetadata() const;
  ::collector::Aws* _internal_mutable_awsmetadata();
  public:
  void unsafe_arena_set_allocated_awsmetadata(
      ::collector::Aws* awsmetadata);
  ::collector::Aws* unsafe_arena_release_awsmetadata();

  // .collector.Azure azureMetadata = 14;
  bool has_azuremetadata() const;
  private:
  bool _internal_has_azuremetadata() const;
  public:
  void clear_azuremetadata();
  const ::collector::Azure& azuremetadata() const;
  PROTOBUF_NODISCARD ::collector::Azure* release_azuremetadata();
  ::collector::Azure* mutable_azuremetadata();
  void set_allocated_azuremetadata(::collector::Azure* azuremetadata);
  private:
  const ::collector::Azure& _internal_azuremetadata() const;
  ::collector::Azure* _internal_mutable_azuremetadata();
  public:
  void unsafe_arena_set_allocated_azuremetadata(
      ::collector::Azure* azuremetadata);
  ::collector::Azure* unsafe_arena_release_azuremetadata();

  // .collector.K8s k8sMetadata = 15;
  bool has_k8smetadata() const;
  private:
  bool _internal_has_k8smetadata() const;
  public:
  void clear_k8smetadata();
  const ::collector::K8s& k8smetadata() const;
  PROTOBUF_NODISCARD ::collector::K8s* release_k8smetadata();
  ::collector::K8s* mutable_k8smetadata();
  void set_allocated_k8smetadata(::collector::K8s* k8smetadata);
  private:
  const ::collector::K8s& _internal_k8smetadata() const;
  ::collector::K8s* _internal_mutable_k8smetadata();
  public:
  void unsafe_arena_set_allocated_k8smetadata(
      ::collector::K8s* k8smetadata);
  ::collector::K8s* unsafe_arena_release_k8smetadata();

  // int32 pid = 4;
  void clear_pid();
  int32_t pid() const;
  void set_pid(int32_t value);
  private:
  int32_t _internal_pid() const;
  void _internal_set_pid(int32_t value);
  public:

  // .collector.HostType hostType = 11;
  void clear_hosttype();
  ::collector::HostType hosttype() const;
  void set_hosttype(::collector::HostType value);
  private:
  ::collector::HostType _internal_hosttype() const;
  void _internal_set_hosttype(::collector::HostType value);
  public:

  // @@protoc_insertion_point(class_scope:collector.HostID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ip_addresses_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> macaddresses_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ec2instanceid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ec2availabilityzone_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dockercontainerid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr herokudynoid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr azappserviceinstanceid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uamsclientid_;
    ::collector::Aws* awsmetadata_;
    ::collector::Azure* azuremetadata_;
    ::collector::K8s* k8smetadata_;
    int32_t pid_;
    int hosttype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collector_2eproto;
};
// -------------------------------------------------------------------

class OboeSetting_ArgumentsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<OboeSetting_ArgumentsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<OboeSetting_ArgumentsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  OboeSetting_ArgumentsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR OboeSetting_ArgumentsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit OboeSetting_ArgumentsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const OboeSetting_ArgumentsEntry_DoNotUse& other);
  static const OboeSetting_ArgumentsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const OboeSetting_ArgumentsEntry_DoNotUse*>(&_OboeSetting_ArgumentsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "collector.OboeSetting.ArgumentsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_collector_2eproto;
};

// -------------------------------------------------------------------

class OboeSetting final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:collector.OboeSetting) */ {
 public:
  inline OboeSetting() : OboeSetting(nullptr) {}
  ~OboeSetting() override;
  explicit PROTOBUF_CONSTEXPR OboeSetting(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OboeSetting(const OboeSetting& from);
  OboeSetting(OboeSetting&& from) noexcept
    : OboeSetting() {
    *this = ::std::move(from);
  }

  inline OboeSetting& operator=(const OboeSetting& from) {
    CopyFrom(from);
    return *this;
  }
  inline OboeSetting& operator=(OboeSetting&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OboeSetting& default_instance() {
    return *internal_default_instance();
  }
  static inline const OboeSetting* internal_default_instance() {
    return reinterpret_cast<const OboeSetting*>(
               &_OboeSetting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(OboeSetting& a, OboeSetting& b) {
    a.Swap(&b);
  }
  inline void Swap(OboeSetting* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OboeSetting* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OboeSetting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OboeSetting>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OboeSetting& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OboeSetting& from) {
    OboeSetting::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OboeSetting* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "collector.OboeSetting";
  }
  protected:
  explicit OboeSetting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kArgumentsFieldNumber = 7,
    kFlagsFieldNumber = 2,
    kLayerFieldNumber = 5,
    kTimestampFieldNumber = 3,
    kValueFieldNumber = 4,
    kTtlFieldNumber = 8,
    kTypeFieldNumber = 1,
  };
  // map<string, bytes> arguments = 7;
  int arguments_size() const;
  private:
  int _internal_arguments_size() const;
  public:
  void clear_arguments();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_arguments() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_arguments();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      arguments() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_arguments();

  // bytes flags = 2;
  void clear_flags();
  const std::string& flags() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_flags(ArgT0&& arg0, ArgT... args);
  std::string* mutable_flags();
  PROTOBUF_NODISCARD std::string* release_flags();
  void set_allocated_flags(std::string* flags);
  private:
  const std::string& _internal_flags() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_flags(const std::string& value);
  std::string* _internal_mutable_flags();
  public:

  // bytes layer = 5;
  void clear_layer();
  const std::string& layer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_layer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_layer();
  PROTOBUF_NODISCARD std::string* release_layer();
  void set_allocated_layer(std::string* layer);
  private:
  const std::string& _internal_layer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_layer(const std::string& value);
  std::string* _internal_mutable_layer();
  public:

  // int64 timestamp = 3;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // int64 value = 4;
  void clear_value();
  int64_t value() const;
  void set_value(int64_t value);
  private:
  int64_t _internal_value() const;
  void _internal_set_value(int64_t value);
  public:

  // int64 ttl = 8;
  void clear_ttl();
  int64_t ttl() const;
  void set_ttl(int64_t value);
  private:
  int64_t _internal_ttl() const;
  void _internal_set_ttl(int64_t value);
  public:

  // .collector.OboeSettingType type = 1;
  void clear_type();
  ::collector::OboeSettingType type() const;
  void set_type(::collector::OboeSettingType value);
  private:
  ::collector::OboeSettingType _internal_type() const;
  void _internal_set_type(::collector::OboeSettingType value);
  public:

  // @@protoc_insertion_point(class_scope:collector.OboeSetting)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        OboeSetting_ArgumentsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> arguments_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr flags_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr layer_;
    int64_t timestamp_;
    int64_t value_;
    int64_t ttl_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collector_2eproto;
};
// -------------------------------------------------------------------

class MessageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:collector.MessageRequest) */ {
 public:
  inline MessageRequest() : MessageRequest(nullptr) {}
  ~MessageRequest() override;
  explicit PROTOBUF_CONSTEXPR MessageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessageRequest(const MessageRequest& from);
  MessageRequest(MessageRequest&& from) noexcept
    : MessageRequest() {
    *this = ::std::move(from);
  }

  inline MessageRequest& operator=(const MessageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageRequest& operator=(MessageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageRequest* internal_default_instance() {
    return reinterpret_cast<const MessageRequest*>(
               &_MessageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MessageRequest& a, MessageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MessageRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MessageRequest& from) {
    MessageRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "collector.MessageRequest";
  }
  protected:
  explicit MessageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessagesFieldNumber = 2,
    kApiKeyFieldNumber = 1,
    kIdentityFieldNumber = 4,
    kEncodingFieldNumber = 3,
  };
  // repeated bytes messages = 2;
  int messages_size() const;
  private:
  int _internal_messages_size() const;
  public:
  void clear_messages();
  const std::string& messages(int index) const;
  std::string* mutable_messages(int index);
  void set_messages(int index, const std::string& value);
  void set_messages(int index, std::string&& value);
  void set_messages(int index, const char* value);
  void set_messages(int index, const void* value, size_t size);
  std::string* add_messages();
  void add_messages(const std::string& value);
  void add_messages(std::string&& value);
  void add_messages(const char* value);
  void add_messages(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& messages() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_messages();
  private:
  const std::string& _internal_messages(int index) const;
  std::string* _internal_add_messages();
  public:

  // string api_key = 1;
  void clear_api_key();
  const std::string& api_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_api_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_api_key();
  PROTOBUF_NODISCARD std::string* release_api_key();
  void set_allocated_api_key(std::string* api_key);
  private:
  const std::string& _internal_api_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_api_key(const std::string& value);
  std::string* _internal_mutable_api_key();
  public:

  // .collector.HostID identity = 4;
  bool has_identity() const;
  private:
  bool _internal_has_identity() const;
  public:
  void clear_identity();
  const ::collector::HostID& identity() const;
  PROTOBUF_NODISCARD ::collector::HostID* release_identity();
  ::collector::HostID* mutable_identity();
  void set_allocated_identity(::collector::HostID* identity);
  private:
  const ::collector::HostID& _internal_identity() const;
  ::collector::HostID* _internal_mutable_identity();
  public:
  void unsafe_arena_set_allocated_identity(
      ::collector::HostID* identity);
  ::collector::HostID* unsafe_arena_release_identity();

  // .collector.EncodingType encoding = 3;
  void clear_encoding();
  ::collector::EncodingType encoding() const;
  void set_encoding(::collector::EncodingType value);
  private:
  ::collector::EncodingType _internal_encoding() const;
  void _internal_set_encoding(::collector::EncodingType value);
  public:

  // @@protoc_insertion_point(class_scope:collector.MessageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> messages_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr api_key_;
    ::collector::HostID* identity_;
    int encoding_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collector_2eproto;
};
// -------------------------------------------------------------------

class MessageResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:collector.MessageResult) */ {
 public:
  inline MessageResult() : MessageResult(nullptr) {}
  ~MessageResult() override;
  explicit PROTOBUF_CONSTEXPR MessageResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessageResult(const MessageResult& from);
  MessageResult(MessageResult&& from) noexcept
    : MessageResult() {
    *this = ::std::move(from);
  }

  inline MessageResult& operator=(const MessageResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageResult& operator=(MessageResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageResult* internal_default_instance() {
    return reinterpret_cast<const MessageResult*>(
               &_MessageResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MessageResult& a, MessageResult& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MessageResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MessageResult& from) {
    MessageResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "collector.MessageResult";
  }
  protected:
  explicit MessageResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgFieldNumber = 2,
    kWarningFieldNumber = 4,
    kResultFieldNumber = 1,
  };
  // string arg = 2;
  void clear_arg();
  const std::string& arg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_arg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_arg();
  PROTOBUF_NODISCARD std::string* release_arg();
  void set_allocated_arg(std::string* arg);
  private:
  const std::string& _internal_arg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_arg(const std::string& value);
  std::string* _internal_mutable_arg();
  public:

  // string warning = 4;
  void clear_warning();
  const std::string& warning() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_warning(ArgT0&& arg0, ArgT... args);
  std::string* mutable_warning();
  PROTOBUF_NODISCARD std::string* release_warning();
  void set_allocated_warning(std::string* warning);
  private:
  const std::string& _internal_warning() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_warning(const std::string& value);
  std::string* _internal_mutable_warning();
  public:

  // .collector.ResultCode result = 1;
  void clear_result();
  ::collector::ResultCode result() const;
  void set_result(::collector::ResultCode value);
  private:
  ::collector::ResultCode _internal_result() const;
  void _internal_set_result(::collector::ResultCode value);
  public:

  // @@protoc_insertion_point(class_scope:collector.MessageResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr arg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr warning_;
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collector_2eproto;
};
// -------------------------------------------------------------------

class SettingsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:collector.SettingsRequest) */ {
 public:
  inline SettingsRequest() : SettingsRequest(nullptr) {}
  ~SettingsRequest() override;
  explicit PROTOBUF_CONSTEXPR SettingsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SettingsRequest(const SettingsRequest& from);
  SettingsRequest(SettingsRequest&& from) noexcept
    : SettingsRequest() {
    *this = ::std::move(from);
  }

  inline SettingsRequest& operator=(const SettingsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SettingsRequest& operator=(SettingsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SettingsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SettingsRequest* internal_default_instance() {
    return reinterpret_cast<const SettingsRequest*>(
               &_SettingsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SettingsRequest& a, SettingsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SettingsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SettingsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SettingsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SettingsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SettingsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SettingsRequest& from) {
    SettingsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SettingsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "collector.SettingsRequest";
  }
  protected:
  explicit SettingsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kApiKeyFieldNumber = 1,
    kClientVersionFieldNumber = 3,
    kIdentityFieldNumber = 2,
  };
  // string api_key = 1;
  void clear_api_key();
  const std::string& api_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_api_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_api_key();
  PROTOBUF_NODISCARD std::string* release_api_key();
  void set_allocated_api_key(std::string* api_key);
  private:
  const std::string& _internal_api_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_api_key(const std::string& value);
  std::string* _internal_mutable_api_key();
  public:

  // string clientVersion = 3;
  void clear_clientversion();
  const std::string& clientversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientversion();
  PROTOBUF_NODISCARD std::string* release_clientversion();
  void set_allocated_clientversion(std::string* clientversion);
  private:
  const std::string& _internal_clientversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientversion(const std::string& value);
  std::string* _internal_mutable_clientversion();
  public:

  // .collector.HostID identity = 2;
  bool has_identity() const;
  private:
  bool _internal_has_identity() const;
  public:
  void clear_identity();
  const ::collector::HostID& identity() const;
  PROTOBUF_NODISCARD ::collector::HostID* release_identity();
  ::collector::HostID* mutable_identity();
  void set_allocated_identity(::collector::HostID* identity);
  private:
  const ::collector::HostID& _internal_identity() const;
  ::collector::HostID* _internal_mutable_identity();
  public:
  void unsafe_arena_set_allocated_identity(
      ::collector::HostID* identity);
  ::collector::HostID* unsafe_arena_release_identity();

  // @@protoc_insertion_point(class_scope:collector.SettingsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr api_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientversion_;
    ::collector::HostID* identity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collector_2eproto;
};
// -------------------------------------------------------------------

class SettingsResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:collector.SettingsResult) */ {
 public:
  inline SettingsResult() : SettingsResult(nullptr) {}
  ~SettingsResult() override;
  explicit PROTOBUF_CONSTEXPR SettingsResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SettingsResult(const SettingsResult& from);
  SettingsResult(SettingsResult&& from) noexcept
    : SettingsResult() {
    *this = ::std::move(from);
  }

  inline SettingsResult& operator=(const SettingsResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SettingsResult& operator=(SettingsResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SettingsResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const SettingsResult* internal_default_instance() {
    return reinterpret_cast<const SettingsResult*>(
               &_SettingsResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SettingsResult& a, SettingsResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SettingsResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SettingsResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SettingsResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SettingsResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SettingsResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SettingsResult& from) {
    SettingsResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SettingsResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "collector.SettingsResult";
  }
  protected:
  explicit SettingsResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSettingsFieldNumber = 3,
    kArgFieldNumber = 2,
    kWarningFieldNumber = 4,
    kResultFieldNumber = 1,
  };
  // repeated .collector.OboeSetting settings = 3;
  int settings_size() const;
  private:
  int _internal_settings_size() const;
  public:
  void clear_settings();
  ::collector::OboeSetting* mutable_settings(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::collector::OboeSetting >*
      mutable_settings();
  private:
  const ::collector::OboeSetting& _internal_settings(int index) const;
  ::collector::OboeSetting* _internal_add_settings();
  public:
  const ::collector::OboeSetting& settings(int index) const;
  ::collector::OboeSetting* add_settings();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::collector::OboeSetting >&
      settings() const;

  // string arg = 2;
  void clear_arg();
  const std::string& arg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_arg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_arg();
  PROTOBUF_NODISCARD std::string* release_arg();
  void set_allocated_arg(std::string* arg);
  private:
  const std::string& _internal_arg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_arg(const std::string& value);
  std::string* _internal_mutable_arg();
  public:

  // string warning = 4;
  void clear_warning();
  const std::string& warning() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_warning(ArgT0&& arg0, ArgT... args);
  std::string* mutable_warning();
  PROTOBUF_NODISCARD std::string* release_warning();
  void set_allocated_warning(std::string* warning);
  private:
  const std::string& _internal_warning() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_warning(const std::string& value);
  std::string* _internal_mutable_warning();
  public:

  // .collector.ResultCode result = 1;
  void clear_result();
  ::collector::ResultCode result() const;
  void set_result(::collector::ResultCode value);
  private:
  ::collector::ResultCode _internal_result() const;
  void _internal_set_result(::collector::ResultCode value);
  public:

  // @@protoc_insertion_point(class_scope:collector.SettingsResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::collector::OboeSetting > settings_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr arg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr warning_;
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collector_2eproto;
};
// -------------------------------------------------------------------

class PingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:collector.PingRequest) */ {
 public:
  inline PingRequest() : PingRequest(nullptr) {}
  ~PingRequest() override;
  explicit PROTOBUF_CONSTEXPR PingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PingRequest(const PingRequest& from);
  PingRequest(PingRequest&& from) noexcept
    : PingRequest() {
    *this = ::std::move(from);
  }

  inline PingRequest& operator=(const PingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingRequest& operator=(PingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PingRequest* internal_default_instance() {
    return reinterpret_cast<const PingRequest*>(
               &_PingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PingRequest& a, PingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PingRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PingRequest& from) {
    PingRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PingRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "collector.PingRequest";
  }
  protected:
  explicit PingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kApiKeyFieldNumber = 1,
  };
  // string api_key = 1;
  void clear_api_key();
  const std::string& api_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_api_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_api_key();
  PROTOBUF_NODISCARD std::string* release_api_key();
  void set_allocated_api_key(std::string* api_key);
  private:
  const std::string& _internal_api_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_api_key(const std::string& value);
  std::string* _internal_mutable_api_key();
  public:

  // @@protoc_insertion_point(class_scope:collector.PingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr api_key_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_collector_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Aws

// string cloudProvider = 1;
inline void Aws::clear_cloudprovider() {
  _impl_.cloudprovider_.ClearToEmpty();
}
inline const std::string& Aws::cloudprovider() const {
  // @@protoc_insertion_point(field_get:collector.Aws.cloudProvider)
  return _internal_cloudprovider();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Aws::set_cloudprovider(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cloudprovider_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.Aws.cloudProvider)
}
inline std::string* Aws::mutable_cloudprovider() {
  std::string* _s = _internal_mutable_cloudprovider();
  // @@protoc_insertion_point(field_mutable:collector.Aws.cloudProvider)
  return _s;
}
inline const std::string& Aws::_internal_cloudprovider() const {
  return _impl_.cloudprovider_.Get();
}
inline void Aws::_internal_set_cloudprovider(const std::string& value) {
  
  _impl_.cloudprovider_.Set(value, GetArenaForAllocation());
}
inline std::string* Aws::_internal_mutable_cloudprovider() {
  
  return _impl_.cloudprovider_.Mutable(GetArenaForAllocation());
}
inline std::string* Aws::release_cloudprovider() {
  // @@protoc_insertion_point(field_release:collector.Aws.cloudProvider)
  return _impl_.cloudprovider_.Release();
}
inline void Aws::set_allocated_cloudprovider(std::string* cloudprovider) {
  if (cloudprovider != nullptr) {
    
  } else {
    
  }
  _impl_.cloudprovider_.SetAllocated(cloudprovider, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cloudprovider_.IsDefault()) {
    _impl_.cloudprovider_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.Aws.cloudProvider)
}

// string cloudPlatform = 2;
inline void Aws::clear_cloudplatform() {
  _impl_.cloudplatform_.ClearToEmpty();
}
inline const std::string& Aws::cloudplatform() const {
  // @@protoc_insertion_point(field_get:collector.Aws.cloudPlatform)
  return _internal_cloudplatform();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Aws::set_cloudplatform(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cloudplatform_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.Aws.cloudPlatform)
}
inline std::string* Aws::mutable_cloudplatform() {
  std::string* _s = _internal_mutable_cloudplatform();
  // @@protoc_insertion_point(field_mutable:collector.Aws.cloudPlatform)
  return _s;
}
inline const std::string& Aws::_internal_cloudplatform() const {
  return _impl_.cloudplatform_.Get();
}
inline void Aws::_internal_set_cloudplatform(const std::string& value) {
  
  _impl_.cloudplatform_.Set(value, GetArenaForAllocation());
}
inline std::string* Aws::_internal_mutable_cloudplatform() {
  
  return _impl_.cloudplatform_.Mutable(GetArenaForAllocation());
}
inline std::string* Aws::release_cloudplatform() {
  // @@protoc_insertion_point(field_release:collector.Aws.cloudPlatform)
  return _impl_.cloudplatform_.Release();
}
inline void Aws::set_allocated_cloudplatform(std::string* cloudplatform) {
  if (cloudplatform != nullptr) {
    
  } else {
    
  }
  _impl_.cloudplatform_.SetAllocated(cloudplatform, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cloudplatform_.IsDefault()) {
    _impl_.cloudplatform_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.Aws.cloudPlatform)
}

// string cloudAccountId = 3;
inline void Aws::clear_cloudaccountid() {
  _impl_.cloudaccountid_.ClearToEmpty();
}
inline const std::string& Aws::cloudaccountid() const {
  // @@protoc_insertion_point(field_get:collector.Aws.cloudAccountId)
  return _internal_cloudaccountid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Aws::set_cloudaccountid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cloudaccountid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.Aws.cloudAccountId)
}
inline std::string* Aws::mutable_cloudaccountid() {
  std::string* _s = _internal_mutable_cloudaccountid();
  // @@protoc_insertion_point(field_mutable:collector.Aws.cloudAccountId)
  return _s;
}
inline const std::string& Aws::_internal_cloudaccountid() const {
  return _impl_.cloudaccountid_.Get();
}
inline void Aws::_internal_set_cloudaccountid(const std::string& value) {
  
  _impl_.cloudaccountid_.Set(value, GetArenaForAllocation());
}
inline std::string* Aws::_internal_mutable_cloudaccountid() {
  
  return _impl_.cloudaccountid_.Mutable(GetArenaForAllocation());
}
inline std::string* Aws::release_cloudaccountid() {
  // @@protoc_insertion_point(field_release:collector.Aws.cloudAccountId)
  return _impl_.cloudaccountid_.Release();
}
inline void Aws::set_allocated_cloudaccountid(std::string* cloudaccountid) {
  if (cloudaccountid != nullptr) {
    
  } else {
    
  }
  _impl_.cloudaccountid_.SetAllocated(cloudaccountid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cloudaccountid_.IsDefault()) {
    _impl_.cloudaccountid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.Aws.cloudAccountId)
}

// string cloudRegion = 4;
inline void Aws::clear_cloudregion() {
  _impl_.cloudregion_.ClearToEmpty();
}
inline const std::string& Aws::cloudregion() const {
  // @@protoc_insertion_point(field_get:collector.Aws.cloudRegion)
  return _internal_cloudregion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Aws::set_cloudregion(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cloudregion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.Aws.cloudRegion)
}
inline std::string* Aws::mutable_cloudregion() {
  std::string* _s = _internal_mutable_cloudregion();
  // @@protoc_insertion_point(field_mutable:collector.Aws.cloudRegion)
  return _s;
}
inline const std::string& Aws::_internal_cloudregion() const {
  return _impl_.cloudregion_.Get();
}
inline void Aws::_internal_set_cloudregion(const std::string& value) {
  
  _impl_.cloudregion_.Set(value, GetArenaForAllocation());
}
inline std::string* Aws::_internal_mutable_cloudregion() {
  
  return _impl_.cloudregion_.Mutable(GetArenaForAllocation());
}
inline std::string* Aws::release_cloudregion() {
  // @@protoc_insertion_point(field_release:collector.Aws.cloudRegion)
  return _impl_.cloudregion_.Release();
}
inline void Aws::set_allocated_cloudregion(std::string* cloudregion) {
  if (cloudregion != nullptr) {
    
  } else {
    
  }
  _impl_.cloudregion_.SetAllocated(cloudregion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cloudregion_.IsDefault()) {
    _impl_.cloudregion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.Aws.cloudRegion)
}

// string cloudAvailabilityZone = 5;
inline void Aws::clear_cloudavailabilityzone() {
  _impl_.cloudavailabilityzone_.ClearToEmpty();
}
inline const std::string& Aws::cloudavailabilityzone() const {
  // @@protoc_insertion_point(field_get:collector.Aws.cloudAvailabilityZone)
  return _internal_cloudavailabilityzone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Aws::set_cloudavailabilityzone(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cloudavailabilityzone_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.Aws.cloudAvailabilityZone)
}
inline std::string* Aws::mutable_cloudavailabilityzone() {
  std::string* _s = _internal_mutable_cloudavailabilityzone();
  // @@protoc_insertion_point(field_mutable:collector.Aws.cloudAvailabilityZone)
  return _s;
}
inline const std::string& Aws::_internal_cloudavailabilityzone() const {
  return _impl_.cloudavailabilityzone_.Get();
}
inline void Aws::_internal_set_cloudavailabilityzone(const std::string& value) {
  
  _impl_.cloudavailabilityzone_.Set(value, GetArenaForAllocation());
}
inline std::string* Aws::_internal_mutable_cloudavailabilityzone() {
  
  return _impl_.cloudavailabilityzone_.Mutable(GetArenaForAllocation());
}
inline std::string* Aws::release_cloudavailabilityzone() {
  // @@protoc_insertion_point(field_release:collector.Aws.cloudAvailabilityZone)
  return _impl_.cloudavailabilityzone_.Release();
}
inline void Aws::set_allocated_cloudavailabilityzone(std::string* cloudavailabilityzone) {
  if (cloudavailabilityzone != nullptr) {
    
  } else {
    
  }
  _impl_.cloudavailabilityzone_.SetAllocated(cloudavailabilityzone, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cloudavailabilityzone_.IsDefault()) {
    _impl_.cloudavailabilityzone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.Aws.cloudAvailabilityZone)
}

// string hostId = 6;
inline void Aws::clear_hostid() {
  _impl_.hostid_.ClearToEmpty();
}
inline const std::string& Aws::hostid() const {
  // @@protoc_insertion_point(field_get:collector.Aws.hostId)
  return _internal_hostid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Aws::set_hostid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hostid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.Aws.hostId)
}
inline std::string* Aws::mutable_hostid() {
  std::string* _s = _internal_mutable_hostid();
  // @@protoc_insertion_point(field_mutable:collector.Aws.hostId)
  return _s;
}
inline const std::string& Aws::_internal_hostid() const {
  return _impl_.hostid_.Get();
}
inline void Aws::_internal_set_hostid(const std::string& value) {
  
  _impl_.hostid_.Set(value, GetArenaForAllocation());
}
inline std::string* Aws::_internal_mutable_hostid() {
  
  return _impl_.hostid_.Mutable(GetArenaForAllocation());
}
inline std::string* Aws::release_hostid() {
  // @@protoc_insertion_point(field_release:collector.Aws.hostId)
  return _impl_.hostid_.Release();
}
inline void Aws::set_allocated_hostid(std::string* hostid) {
  if (hostid != nullptr) {
    
  } else {
    
  }
  _impl_.hostid_.SetAllocated(hostid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostid_.IsDefault()) {
    _impl_.hostid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.Aws.hostId)
}

// string hostImageId = 7;
inline void Aws::clear_hostimageid() {
  _impl_.hostimageid_.ClearToEmpty();
}
inline const std::string& Aws::hostimageid() const {
  // @@protoc_insertion_point(field_get:collector.Aws.hostImageId)
  return _internal_hostimageid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Aws::set_hostimageid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hostimageid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.Aws.hostImageId)
}
inline std::string* Aws::mutable_hostimageid() {
  std::string* _s = _internal_mutable_hostimageid();
  // @@protoc_insertion_point(field_mutable:collector.Aws.hostImageId)
  return _s;
}
inline const std::string& Aws::_internal_hostimageid() const {
  return _impl_.hostimageid_.Get();
}
inline void Aws::_internal_set_hostimageid(const std::string& value) {
  
  _impl_.hostimageid_.Set(value, GetArenaForAllocation());
}
inline std::string* Aws::_internal_mutable_hostimageid() {
  
  return _impl_.hostimageid_.Mutable(GetArenaForAllocation());
}
inline std::string* Aws::release_hostimageid() {
  // @@protoc_insertion_point(field_release:collector.Aws.hostImageId)
  return _impl_.hostimageid_.Release();
}
inline void Aws::set_allocated_hostimageid(std::string* hostimageid) {
  if (hostimageid != nullptr) {
    
  } else {
    
  }
  _impl_.hostimageid_.SetAllocated(hostimageid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostimageid_.IsDefault()) {
    _impl_.hostimageid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.Aws.hostImageId)
}

// string hostName = 8;
inline void Aws::clear_hostname() {
  _impl_.hostname_.ClearToEmpty();
}
inline const std::string& Aws::hostname() const {
  // @@protoc_insertion_point(field_get:collector.Aws.hostName)
  return _internal_hostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Aws::set_hostname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.Aws.hostName)
}
inline std::string* Aws::mutable_hostname() {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:collector.Aws.hostName)
  return _s;
}
inline const std::string& Aws::_internal_hostname() const {
  return _impl_.hostname_.Get();
}
inline void Aws::_internal_set_hostname(const std::string& value) {
  
  _impl_.hostname_.Set(value, GetArenaForAllocation());
}
inline std::string* Aws::_internal_mutable_hostname() {
  
  return _impl_.hostname_.Mutable(GetArenaForAllocation());
}
inline std::string* Aws::release_hostname() {
  // @@protoc_insertion_point(field_release:collector.Aws.hostName)
  return _impl_.hostname_.Release();
}
inline void Aws::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    
  } else {
    
  }
  _impl_.hostname_.SetAllocated(hostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostname_.IsDefault()) {
    _impl_.hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.Aws.hostName)
}

// string hostType = 9;
inline void Aws::clear_hosttype() {
  _impl_.hosttype_.ClearToEmpty();
}
inline const std::string& Aws::hosttype() const {
  // @@protoc_insertion_point(field_get:collector.Aws.hostType)
  return _internal_hosttype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Aws::set_hosttype(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hosttype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.Aws.hostType)
}
inline std::string* Aws::mutable_hosttype() {
  std::string* _s = _internal_mutable_hosttype();
  // @@protoc_insertion_point(field_mutable:collector.Aws.hostType)
  return _s;
}
inline const std::string& Aws::_internal_hosttype() const {
  return _impl_.hosttype_.Get();
}
inline void Aws::_internal_set_hosttype(const std::string& value) {
  
  _impl_.hosttype_.Set(value, GetArenaForAllocation());
}
inline std::string* Aws::_internal_mutable_hosttype() {
  
  return _impl_.hosttype_.Mutable(GetArenaForAllocation());
}
inline std::string* Aws::release_hosttype() {
  // @@protoc_insertion_point(field_release:collector.Aws.hostType)
  return _impl_.hosttype_.Release();
}
inline void Aws::set_allocated_hosttype(std::string* hosttype) {
  if (hosttype != nullptr) {
    
  } else {
    
  }
  _impl_.hosttype_.SetAllocated(hosttype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hosttype_.IsDefault()) {
    _impl_.hosttype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.Aws.hostType)
}

// -------------------------------------------------------------------

// Azure

// string cloudProvider = 1;
inline void Azure::clear_cloudprovider() {
  _impl_.cloudprovider_.ClearToEmpty();
}
inline const std::string& Azure::cloudprovider() const {
  // @@protoc_insertion_point(field_get:collector.Azure.cloudProvider)
  return _internal_cloudprovider();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Azure::set_cloudprovider(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cloudprovider_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.Azure.cloudProvider)
}
inline std::string* Azure::mutable_cloudprovider() {
  std::string* _s = _internal_mutable_cloudprovider();
  // @@protoc_insertion_point(field_mutable:collector.Azure.cloudProvider)
  return _s;
}
inline const std::string& Azure::_internal_cloudprovider() const {
  return _impl_.cloudprovider_.Get();
}
inline void Azure::_internal_set_cloudprovider(const std::string& value) {
  
  _impl_.cloudprovider_.Set(value, GetArenaForAllocation());
}
inline std::string* Azure::_internal_mutable_cloudprovider() {
  
  return _impl_.cloudprovider_.Mutable(GetArenaForAllocation());
}
inline std::string* Azure::release_cloudprovider() {
  // @@protoc_insertion_point(field_release:collector.Azure.cloudProvider)
  return _impl_.cloudprovider_.Release();
}
inline void Azure::set_allocated_cloudprovider(std::string* cloudprovider) {
  if (cloudprovider != nullptr) {
    
  } else {
    
  }
  _impl_.cloudprovider_.SetAllocated(cloudprovider, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cloudprovider_.IsDefault()) {
    _impl_.cloudprovider_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.Azure.cloudProvider)
}

// string cloudPlatform = 2;
inline void Azure::clear_cloudplatform() {
  _impl_.cloudplatform_.ClearToEmpty();
}
inline const std::string& Azure::cloudplatform() const {
  // @@protoc_insertion_point(field_get:collector.Azure.cloudPlatform)
  return _internal_cloudplatform();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Azure::set_cloudplatform(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cloudplatform_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.Azure.cloudPlatform)
}
inline std::string* Azure::mutable_cloudplatform() {
  std::string* _s = _internal_mutable_cloudplatform();
  // @@protoc_insertion_point(field_mutable:collector.Azure.cloudPlatform)
  return _s;
}
inline const std::string& Azure::_internal_cloudplatform() const {
  return _impl_.cloudplatform_.Get();
}
inline void Azure::_internal_set_cloudplatform(const std::string& value) {
  
  _impl_.cloudplatform_.Set(value, GetArenaForAllocation());
}
inline std::string* Azure::_internal_mutable_cloudplatform() {
  
  return _impl_.cloudplatform_.Mutable(GetArenaForAllocation());
}
inline std::string* Azure::release_cloudplatform() {
  // @@protoc_insertion_point(field_release:collector.Azure.cloudPlatform)
  return _impl_.cloudplatform_.Release();
}
inline void Azure::set_allocated_cloudplatform(std::string* cloudplatform) {
  if (cloudplatform != nullptr) {
    
  } else {
    
  }
  _impl_.cloudplatform_.SetAllocated(cloudplatform, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cloudplatform_.IsDefault()) {
    _impl_.cloudplatform_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.Azure.cloudPlatform)
}

// string cloudRegion = 3;
inline void Azure::clear_cloudregion() {
  _impl_.cloudregion_.ClearToEmpty();
}
inline const std::string& Azure::cloudregion() const {
  // @@protoc_insertion_point(field_get:collector.Azure.cloudRegion)
  return _internal_cloudregion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Azure::set_cloudregion(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cloudregion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.Azure.cloudRegion)
}
inline std::string* Azure::mutable_cloudregion() {
  std::string* _s = _internal_mutable_cloudregion();
  // @@protoc_insertion_point(field_mutable:collector.Azure.cloudRegion)
  return _s;
}
inline const std::string& Azure::_internal_cloudregion() const {
  return _impl_.cloudregion_.Get();
}
inline void Azure::_internal_set_cloudregion(const std::string& value) {
  
  _impl_.cloudregion_.Set(value, GetArenaForAllocation());
}
inline std::string* Azure::_internal_mutable_cloudregion() {
  
  return _impl_.cloudregion_.Mutable(GetArenaForAllocation());
}
inline std::string* Azure::release_cloudregion() {
  // @@protoc_insertion_point(field_release:collector.Azure.cloudRegion)
  return _impl_.cloudregion_.Release();
}
inline void Azure::set_allocated_cloudregion(std::string* cloudregion) {
  if (cloudregion != nullptr) {
    
  } else {
    
  }
  _impl_.cloudregion_.SetAllocated(cloudregion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cloudregion_.IsDefault()) {
    _impl_.cloudregion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.Azure.cloudRegion)
}

// string cloudAccountId = 4;
inline void Azure::clear_cloudaccountid() {
  _impl_.cloudaccountid_.ClearToEmpty();
}
inline const std::string& Azure::cloudaccountid() const {
  // @@protoc_insertion_point(field_get:collector.Azure.cloudAccountId)
  return _internal_cloudaccountid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Azure::set_cloudaccountid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cloudaccountid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.Azure.cloudAccountId)
}
inline std::string* Azure::mutable_cloudaccountid() {
  std::string* _s = _internal_mutable_cloudaccountid();
  // @@protoc_insertion_point(field_mutable:collector.Azure.cloudAccountId)
  return _s;
}
inline const std::string& Azure::_internal_cloudaccountid() const {
  return _impl_.cloudaccountid_.Get();
}
inline void Azure::_internal_set_cloudaccountid(const std::string& value) {
  
  _impl_.cloudaccountid_.Set(value, GetArenaForAllocation());
}
inline std::string* Azure::_internal_mutable_cloudaccountid() {
  
  return _impl_.cloudaccountid_.Mutable(GetArenaForAllocation());
}
inline std::string* Azure::release_cloudaccountid() {
  // @@protoc_insertion_point(field_release:collector.Azure.cloudAccountId)
  return _impl_.cloudaccountid_.Release();
}
inline void Azure::set_allocated_cloudaccountid(std::string* cloudaccountid) {
  if (cloudaccountid != nullptr) {
    
  } else {
    
  }
  _impl_.cloudaccountid_.SetAllocated(cloudaccountid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cloudaccountid_.IsDefault()) {
    _impl_.cloudaccountid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.Azure.cloudAccountId)
}

// string hostId = 5;
inline void Azure::clear_hostid() {
  _impl_.hostid_.ClearToEmpty();
}
inline const std::string& Azure::hostid() const {
  // @@protoc_insertion_point(field_get:collector.Azure.hostId)
  return _internal_hostid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Azure::set_hostid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hostid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.Azure.hostId)
}
inline std::string* Azure::mutable_hostid() {
  std::string* _s = _internal_mutable_hostid();
  // @@protoc_insertion_point(field_mutable:collector.Azure.hostId)
  return _s;
}
inline const std::string& Azure::_internal_hostid() const {
  return _impl_.hostid_.Get();
}
inline void Azure::_internal_set_hostid(const std::string& value) {
  
  _impl_.hostid_.Set(value, GetArenaForAllocation());
}
inline std::string* Azure::_internal_mutable_hostid() {
  
  return _impl_.hostid_.Mutable(GetArenaForAllocation());
}
inline std::string* Azure::release_hostid() {
  // @@protoc_insertion_point(field_release:collector.Azure.hostId)
  return _impl_.hostid_.Release();
}
inline void Azure::set_allocated_hostid(std::string* hostid) {
  if (hostid != nullptr) {
    
  } else {
    
  }
  _impl_.hostid_.SetAllocated(hostid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostid_.IsDefault()) {
    _impl_.hostid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.Azure.hostId)
}

// string hostName = 6;
inline void Azure::clear_hostname() {
  _impl_.hostname_.ClearToEmpty();
}
inline const std::string& Azure::hostname() const {
  // @@protoc_insertion_point(field_get:collector.Azure.hostName)
  return _internal_hostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Azure::set_hostname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.Azure.hostName)
}
inline std::string* Azure::mutable_hostname() {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:collector.Azure.hostName)
  return _s;
}
inline const std::string& Azure::_internal_hostname() const {
  return _impl_.hostname_.Get();
}
inline void Azure::_internal_set_hostname(const std::string& value) {
  
  _impl_.hostname_.Set(value, GetArenaForAllocation());
}
inline std::string* Azure::_internal_mutable_hostname() {
  
  return _impl_.hostname_.Mutable(GetArenaForAllocation());
}
inline std::string* Azure::release_hostname() {
  // @@protoc_insertion_point(field_release:collector.Azure.hostName)
  return _impl_.hostname_.Release();
}
inline void Azure::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    
  } else {
    
  }
  _impl_.hostname_.SetAllocated(hostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostname_.IsDefault()) {
    _impl_.hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.Azure.hostName)
}

// string azureVmName = 7;
inline void Azure::clear_azurevmname() {
  _impl_.azurevmname_.ClearToEmpty();
}
inline const std::string& Azure::azurevmname() const {
  // @@protoc_insertion_point(field_get:collector.Azure.azureVmName)
  return _internal_azurevmname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Azure::set_azurevmname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.azurevmname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.Azure.azureVmName)
}
inline std::string* Azure::mutable_azurevmname() {
  std::string* _s = _internal_mutable_azurevmname();
  // @@protoc_insertion_point(field_mutable:collector.Azure.azureVmName)
  return _s;
}
inline const std::string& Azure::_internal_azurevmname() const {
  return _impl_.azurevmname_.Get();
}
inline void Azure::_internal_set_azurevmname(const std::string& value) {
  
  _impl_.azurevmname_.Set(value, GetArenaForAllocation());
}
inline std::string* Azure::_internal_mutable_azurevmname() {
  
  return _impl_.azurevmname_.Mutable(GetArenaForAllocation());
}
inline std::string* Azure::release_azurevmname() {
  // @@protoc_insertion_point(field_release:collector.Azure.azureVmName)
  return _impl_.azurevmname_.Release();
}
inline void Azure::set_allocated_azurevmname(std::string* azurevmname) {
  if (azurevmname != nullptr) {
    
  } else {
    
  }
  _impl_.azurevmname_.SetAllocated(azurevmname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.azurevmname_.IsDefault()) {
    _impl_.azurevmname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.Azure.azureVmName)
}

// string azureVmSize = 8;
inline void Azure::clear_azurevmsize() {
  _impl_.azurevmsize_.ClearToEmpty();
}
inline const std::string& Azure::azurevmsize() const {
  // @@protoc_insertion_point(field_get:collector.Azure.azureVmSize)
  return _internal_azurevmsize();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Azure::set_azurevmsize(ArgT0&& arg0, ArgT... args) {
 
 _impl_.azurevmsize_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.Azure.azureVmSize)
}
inline std::string* Azure::mutable_azurevmsize() {
  std::string* _s = _internal_mutable_azurevmsize();
  // @@protoc_insertion_point(field_mutable:collector.Azure.azureVmSize)
  return _s;
}
inline const std::string& Azure::_internal_azurevmsize() const {
  return _impl_.azurevmsize_.Get();
}
inline void Azure::_internal_set_azurevmsize(const std::string& value) {
  
  _impl_.azurevmsize_.Set(value, GetArenaForAllocation());
}
inline std::string* Azure::_internal_mutable_azurevmsize() {
  
  return _impl_.azurevmsize_.Mutable(GetArenaForAllocation());
}
inline std::string* Azure::release_azurevmsize() {
  // @@protoc_insertion_point(field_release:collector.Azure.azureVmSize)
  return _impl_.azurevmsize_.Release();
}
inline void Azure::set_allocated_azurevmsize(std::string* azurevmsize) {
  if (azurevmsize != nullptr) {
    
  } else {
    
  }
  _impl_.azurevmsize_.SetAllocated(azurevmsize, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.azurevmsize_.IsDefault()) {
    _impl_.azurevmsize_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.Azure.azureVmSize)
}

// string azureVmScaleSetName = 9;
inline void Azure::clear_azurevmscalesetname() {
  _impl_.azurevmscalesetname_.ClearToEmpty();
}
inline const std::string& Azure::azurevmscalesetname() const {
  // @@protoc_insertion_point(field_get:collector.Azure.azureVmScaleSetName)
  return _internal_azurevmscalesetname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Azure::set_azurevmscalesetname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.azurevmscalesetname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.Azure.azureVmScaleSetName)
}
inline std::string* Azure::mutable_azurevmscalesetname() {
  std::string* _s = _internal_mutable_azurevmscalesetname();
  // @@protoc_insertion_point(field_mutable:collector.Azure.azureVmScaleSetName)
  return _s;
}
inline const std::string& Azure::_internal_azurevmscalesetname() const {
  return _impl_.azurevmscalesetname_.Get();
}
inline void Azure::_internal_set_azurevmscalesetname(const std::string& value) {
  
  _impl_.azurevmscalesetname_.Set(value, GetArenaForAllocation());
}
inline std::string* Azure::_internal_mutable_azurevmscalesetname() {
  
  return _impl_.azurevmscalesetname_.Mutable(GetArenaForAllocation());
}
inline std::string* Azure::release_azurevmscalesetname() {
  // @@protoc_insertion_point(field_release:collector.Azure.azureVmScaleSetName)
  return _impl_.azurevmscalesetname_.Release();
}
inline void Azure::set_allocated_azurevmscalesetname(std::string* azurevmscalesetname) {
  if (azurevmscalesetname != nullptr) {
    
  } else {
    
  }
  _impl_.azurevmscalesetname_.SetAllocated(azurevmscalesetname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.azurevmscalesetname_.IsDefault()) {
    _impl_.azurevmscalesetname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.Azure.azureVmScaleSetName)
}

// string azureResourceGroupName = 10;
inline void Azure::clear_azureresourcegroupname() {
  _impl_.azureresourcegroupname_.ClearToEmpty();
}
inline const std::string& Azure::azureresourcegroupname() const {
  // @@protoc_insertion_point(field_get:collector.Azure.azureResourceGroupName)
  return _internal_azureresourcegroupname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Azure::set_azureresourcegroupname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.azureresourcegroupname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.Azure.azureResourceGroupName)
}
inline std::string* Azure::mutable_azureresourcegroupname() {
  std::string* _s = _internal_mutable_azureresourcegroupname();
  // @@protoc_insertion_point(field_mutable:collector.Azure.azureResourceGroupName)
  return _s;
}
inline const std::string& Azure::_internal_azureresourcegroupname() const {
  return _impl_.azureresourcegroupname_.Get();
}
inline void Azure::_internal_set_azureresourcegroupname(const std::string& value) {
  
  _impl_.azureresourcegroupname_.Set(value, GetArenaForAllocation());
}
inline std::string* Azure::_internal_mutable_azureresourcegroupname() {
  
  return _impl_.azureresourcegroupname_.Mutable(GetArenaForAllocation());
}
inline std::string* Azure::release_azureresourcegroupname() {
  // @@protoc_insertion_point(field_release:collector.Azure.azureResourceGroupName)
  return _impl_.azureresourcegroupname_.Release();
}
inline void Azure::set_allocated_azureresourcegroupname(std::string* azureresourcegroupname) {
  if (azureresourcegroupname != nullptr) {
    
  } else {
    
  }
  _impl_.azureresourcegroupname_.SetAllocated(azureresourcegroupname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.azureresourcegroupname_.IsDefault()) {
    _impl_.azureresourcegroupname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.Azure.azureResourceGroupName)
}

// -------------------------------------------------------------------

// K8s

// string namespace = 1;
inline void K8s::clear_namespace_() {
  _impl_.namespace__.ClearToEmpty();
}
inline const std::string& K8s::namespace_() const {
  // @@protoc_insertion_point(field_get:collector.K8s.namespace)
  return _internal_namespace_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void K8s::set_namespace_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.namespace__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.K8s.namespace)
}
inline std::string* K8s::mutable_namespace_() {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:collector.K8s.namespace)
  return _s;
}
inline const std::string& K8s::_internal_namespace_() const {
  return _impl_.namespace__.Get();
}
inline void K8s::_internal_set_namespace_(const std::string& value) {
  
  _impl_.namespace__.Set(value, GetArenaForAllocation());
}
inline std::string* K8s::_internal_mutable_namespace_() {
  
  return _impl_.namespace__.Mutable(GetArenaForAllocation());
}
inline std::string* K8s::release_namespace_() {
  // @@protoc_insertion_point(field_release:collector.K8s.namespace)
  return _impl_.namespace__.Release();
}
inline void K8s::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    
  } else {
    
  }
  _impl_.namespace__.SetAllocated(namespace_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.namespace__.IsDefault()) {
    _impl_.namespace__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.K8s.namespace)
}

// string podName = 2;
inline void K8s::clear_podname() {
  _impl_.podname_.ClearToEmpty();
}
inline const std::string& K8s::podname() const {
  // @@protoc_insertion_point(field_get:collector.K8s.podName)
  return _internal_podname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void K8s::set_podname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.podname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.K8s.podName)
}
inline std::string* K8s::mutable_podname() {
  std::string* _s = _internal_mutable_podname();
  // @@protoc_insertion_point(field_mutable:collector.K8s.podName)
  return _s;
}
inline const std::string& K8s::_internal_podname() const {
  return _impl_.podname_.Get();
}
inline void K8s::_internal_set_podname(const std::string& value) {
  
  _impl_.podname_.Set(value, GetArenaForAllocation());
}
inline std::string* K8s::_internal_mutable_podname() {
  
  return _impl_.podname_.Mutable(GetArenaForAllocation());
}
inline std::string* K8s::release_podname() {
  // @@protoc_insertion_point(field_release:collector.K8s.podName)
  return _impl_.podname_.Release();
}
inline void K8s::set_allocated_podname(std::string* podname) {
  if (podname != nullptr) {
    
  } else {
    
  }
  _impl_.podname_.SetAllocated(podname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.podname_.IsDefault()) {
    _impl_.podname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.K8s.podName)
}

// string podUid = 3;
inline void K8s::clear_poduid() {
  _impl_.poduid_.ClearToEmpty();
}
inline const std::string& K8s::poduid() const {
  // @@protoc_insertion_point(field_get:collector.K8s.podUid)
  return _internal_poduid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void K8s::set_poduid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.poduid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.K8s.podUid)
}
inline std::string* K8s::mutable_poduid() {
  std::string* _s = _internal_mutable_poduid();
  // @@protoc_insertion_point(field_mutable:collector.K8s.podUid)
  return _s;
}
inline const std::string& K8s::_internal_poduid() const {
  return _impl_.poduid_.Get();
}
inline void K8s::_internal_set_poduid(const std::string& value) {
  
  _impl_.poduid_.Set(value, GetArenaForAllocation());
}
inline std::string* K8s::_internal_mutable_poduid() {
  
  return _impl_.poduid_.Mutable(GetArenaForAllocation());
}
inline std::string* K8s::release_poduid() {
  // @@protoc_insertion_point(field_release:collector.K8s.podUid)
  return _impl_.poduid_.Release();
}
inline void K8s::set_allocated_poduid(std::string* poduid) {
  if (poduid != nullptr) {
    
  } else {
    
  }
  _impl_.poduid_.SetAllocated(poduid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.poduid_.IsDefault()) {
    _impl_.poduid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.K8s.podUid)
}

// string containerId = 4;
inline void K8s::clear_containerid() {
  _impl_.containerid_.ClearToEmpty();
}
inline const std::string& K8s::containerid() const {
  // @@protoc_insertion_point(field_get:collector.K8s.containerId)
  return _internal_containerid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void K8s::set_containerid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.containerid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.K8s.containerId)
}
inline std::string* K8s::mutable_containerid() {
  std::string* _s = _internal_mutable_containerid();
  // @@protoc_insertion_point(field_mutable:collector.K8s.containerId)
  return _s;
}
inline const std::string& K8s::_internal_containerid() const {
  return _impl_.containerid_.Get();
}
inline void K8s::_internal_set_containerid(const std::string& value) {
  
  _impl_.containerid_.Set(value, GetArenaForAllocation());
}
inline std::string* K8s::_internal_mutable_containerid() {
  
  return _impl_.containerid_.Mutable(GetArenaForAllocation());
}
inline std::string* K8s::release_containerid() {
  // @@protoc_insertion_point(field_release:collector.K8s.containerId)
  return _impl_.containerid_.Release();
}
inline void K8s::set_allocated_containerid(std::string* containerid) {
  if (containerid != nullptr) {
    
  } else {
    
  }
  _impl_.containerid_.SetAllocated(containerid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.containerid_.IsDefault()) {
    _impl_.containerid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.K8s.containerId)
}

// -------------------------------------------------------------------

// HostID

// string hostname = 1;
inline void HostID::clear_hostname() {
  _impl_.hostname_.ClearToEmpty();
}
inline const std::string& HostID::hostname() const {
  // @@protoc_insertion_point(field_get:collector.HostID.hostname)
  return _internal_hostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HostID::set_hostname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.HostID.hostname)
}
inline std::string* HostID::mutable_hostname() {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:collector.HostID.hostname)
  return _s;
}
inline const std::string& HostID::_internal_hostname() const {
  return _impl_.hostname_.Get();
}
inline void HostID::_internal_set_hostname(const std::string& value) {
  
  _impl_.hostname_.Set(value, GetArenaForAllocation());
}
inline std::string* HostID::_internal_mutable_hostname() {
  
  return _impl_.hostname_.Mutable(GetArenaForAllocation());
}
inline std::string* HostID::release_hostname() {
  // @@protoc_insertion_point(field_release:collector.HostID.hostname)
  return _impl_.hostname_.Release();
}
inline void HostID::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    
  } else {
    
  }
  _impl_.hostname_.SetAllocated(hostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostname_.IsDefault()) {
    _impl_.hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.HostID.hostname)
}

// repeated string ip_addresses = 2;
inline int HostID::_internal_ip_addresses_size() const {
  return _impl_.ip_addresses_.size();
}
inline int HostID::ip_addresses_size() const {
  return _internal_ip_addresses_size();
}
inline void HostID::clear_ip_addresses() {
  _impl_.ip_addresses_.Clear();
}
inline std::string* HostID::add_ip_addresses() {
  std::string* _s = _internal_add_ip_addresses();
  // @@protoc_insertion_point(field_add_mutable:collector.HostID.ip_addresses)
  return _s;
}
inline const std::string& HostID::_internal_ip_addresses(int index) const {
  return _impl_.ip_addresses_.Get(index);
}
inline const std::string& HostID::ip_addresses(int index) const {
  // @@protoc_insertion_point(field_get:collector.HostID.ip_addresses)
  return _internal_ip_addresses(index);
}
inline std::string* HostID::mutable_ip_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:collector.HostID.ip_addresses)
  return _impl_.ip_addresses_.Mutable(index);
}
inline void HostID::set_ip_addresses(int index, const std::string& value) {
  _impl_.ip_addresses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:collector.HostID.ip_addresses)
}
inline void HostID::set_ip_addresses(int index, std::string&& value) {
  _impl_.ip_addresses_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:collector.HostID.ip_addresses)
}
inline void HostID::set_ip_addresses(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.ip_addresses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:collector.HostID.ip_addresses)
}
inline void HostID::set_ip_addresses(int index, const char* value, size_t size) {
  _impl_.ip_addresses_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:collector.HostID.ip_addresses)
}
inline std::string* HostID::_internal_add_ip_addresses() {
  return _impl_.ip_addresses_.Add();
}
inline void HostID::add_ip_addresses(const std::string& value) {
  _impl_.ip_addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:collector.HostID.ip_addresses)
}
inline void HostID::add_ip_addresses(std::string&& value) {
  _impl_.ip_addresses_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:collector.HostID.ip_addresses)
}
inline void HostID::add_ip_addresses(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.ip_addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:collector.HostID.ip_addresses)
}
inline void HostID::add_ip_addresses(const char* value, size_t size) {
  _impl_.ip_addresses_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:collector.HostID.ip_addresses)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
HostID::ip_addresses() const {
  // @@protoc_insertion_point(field_list:collector.HostID.ip_addresses)
  return _impl_.ip_addresses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
HostID::mutable_ip_addresses() {
  // @@protoc_insertion_point(field_mutable_list:collector.HostID.ip_addresses)
  return &_impl_.ip_addresses_;
}

// string uuid = 3;
inline void HostID::clear_uuid() {
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& HostID::uuid() const {
  // @@protoc_insertion_point(field_get:collector.HostID.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HostID::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.HostID.uuid)
}
inline std::string* HostID::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:collector.HostID.uuid)
  return _s;
}
inline const std::string& HostID::_internal_uuid() const {
  return _impl_.uuid_.Get();
}
inline void HostID::_internal_set_uuid(const std::string& value) {
  
  _impl_.uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* HostID::_internal_mutable_uuid() {
  
  return _impl_.uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* HostID::release_uuid() {
  // @@protoc_insertion_point(field_release:collector.HostID.uuid)
  return _impl_.uuid_.Release();
}
inline void HostID::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  _impl_.uuid_.SetAllocated(uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.HostID.uuid)
}

// int32 pid = 4;
inline void HostID::clear_pid() {
  _impl_.pid_ = 0;
}
inline int32_t HostID::_internal_pid() const {
  return _impl_.pid_;
}
inline int32_t HostID::pid() const {
  // @@protoc_insertion_point(field_get:collector.HostID.pid)
  return _internal_pid();
}
inline void HostID::_internal_set_pid(int32_t value) {
  
  _impl_.pid_ = value;
}
inline void HostID::set_pid(int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:collector.HostID.pid)
}

// string ec2InstanceID = 5;
inline void HostID::clear_ec2instanceid() {
  _impl_.ec2instanceid_.ClearToEmpty();
}
inline const std::string& HostID::ec2instanceid() const {
  // @@protoc_insertion_point(field_get:collector.HostID.ec2InstanceID)
  return _internal_ec2instanceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HostID::set_ec2instanceid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ec2instanceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.HostID.ec2InstanceID)
}
inline std::string* HostID::mutable_ec2instanceid() {
  std::string* _s = _internal_mutable_ec2instanceid();
  // @@protoc_insertion_point(field_mutable:collector.HostID.ec2InstanceID)
  return _s;
}
inline const std::string& HostID::_internal_ec2instanceid() const {
  return _impl_.ec2instanceid_.Get();
}
inline void HostID::_internal_set_ec2instanceid(const std::string& value) {
  
  _impl_.ec2instanceid_.Set(value, GetArenaForAllocation());
}
inline std::string* HostID::_internal_mutable_ec2instanceid() {
  
  return _impl_.ec2instanceid_.Mutable(GetArenaForAllocation());
}
inline std::string* HostID::release_ec2instanceid() {
  // @@protoc_insertion_point(field_release:collector.HostID.ec2InstanceID)
  return _impl_.ec2instanceid_.Release();
}
inline void HostID::set_allocated_ec2instanceid(std::string* ec2instanceid) {
  if (ec2instanceid != nullptr) {
    
  } else {
    
  }
  _impl_.ec2instanceid_.SetAllocated(ec2instanceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ec2instanceid_.IsDefault()) {
    _impl_.ec2instanceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.HostID.ec2InstanceID)
}

// string ec2AvailabilityZone = 6;
inline void HostID::clear_ec2availabilityzone() {
  _impl_.ec2availabilityzone_.ClearToEmpty();
}
inline const std::string& HostID::ec2availabilityzone() const {
  // @@protoc_insertion_point(field_get:collector.HostID.ec2AvailabilityZone)
  return _internal_ec2availabilityzone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HostID::set_ec2availabilityzone(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ec2availabilityzone_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.HostID.ec2AvailabilityZone)
}
inline std::string* HostID::mutable_ec2availabilityzone() {
  std::string* _s = _internal_mutable_ec2availabilityzone();
  // @@protoc_insertion_point(field_mutable:collector.HostID.ec2AvailabilityZone)
  return _s;
}
inline const std::string& HostID::_internal_ec2availabilityzone() const {
  return _impl_.ec2availabilityzone_.Get();
}
inline void HostID::_internal_set_ec2availabilityzone(const std::string& value) {
  
  _impl_.ec2availabilityzone_.Set(value, GetArenaForAllocation());
}
inline std::string* HostID::_internal_mutable_ec2availabilityzone() {
  
  return _impl_.ec2availabilityzone_.Mutable(GetArenaForAllocation());
}
inline std::string* HostID::release_ec2availabilityzone() {
  // @@protoc_insertion_point(field_release:collector.HostID.ec2AvailabilityZone)
  return _impl_.ec2availabilityzone_.Release();
}
inline void HostID::set_allocated_ec2availabilityzone(std::string* ec2availabilityzone) {
  if (ec2availabilityzone != nullptr) {
    
  } else {
    
  }
  _impl_.ec2availabilityzone_.SetAllocated(ec2availabilityzone, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ec2availabilityzone_.IsDefault()) {
    _impl_.ec2availabilityzone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.HostID.ec2AvailabilityZone)
}

// string dockerContainerID = 7;
inline void HostID::clear_dockercontainerid() {
  _impl_.dockercontainerid_.ClearToEmpty();
}
inline const std::string& HostID::dockercontainerid() const {
  // @@protoc_insertion_point(field_get:collector.HostID.dockerContainerID)
  return _internal_dockercontainerid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HostID::set_dockercontainerid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dockercontainerid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.HostID.dockerContainerID)
}
inline std::string* HostID::mutable_dockercontainerid() {
  std::string* _s = _internal_mutable_dockercontainerid();
  // @@protoc_insertion_point(field_mutable:collector.HostID.dockerContainerID)
  return _s;
}
inline const std::string& HostID::_internal_dockercontainerid() const {
  return _impl_.dockercontainerid_.Get();
}
inline void HostID::_internal_set_dockercontainerid(const std::string& value) {
  
  _impl_.dockercontainerid_.Set(value, GetArenaForAllocation());
}
inline std::string* HostID::_internal_mutable_dockercontainerid() {
  
  return _impl_.dockercontainerid_.Mutable(GetArenaForAllocation());
}
inline std::string* HostID::release_dockercontainerid() {
  // @@protoc_insertion_point(field_release:collector.HostID.dockerContainerID)
  return _impl_.dockercontainerid_.Release();
}
inline void HostID::set_allocated_dockercontainerid(std::string* dockercontainerid) {
  if (dockercontainerid != nullptr) {
    
  } else {
    
  }
  _impl_.dockercontainerid_.SetAllocated(dockercontainerid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dockercontainerid_.IsDefault()) {
    _impl_.dockercontainerid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.HostID.dockerContainerID)
}

// repeated string macAddresses = 8;
inline int HostID::_internal_macaddresses_size() const {
  return _impl_.macaddresses_.size();
}
inline int HostID::macaddresses_size() const {
  return _internal_macaddresses_size();
}
inline void HostID::clear_macaddresses() {
  _impl_.macaddresses_.Clear();
}
inline std::string* HostID::add_macaddresses() {
  std::string* _s = _internal_add_macaddresses();
  // @@protoc_insertion_point(field_add_mutable:collector.HostID.macAddresses)
  return _s;
}
inline const std::string& HostID::_internal_macaddresses(int index) const {
  return _impl_.macaddresses_.Get(index);
}
inline const std::string& HostID::macaddresses(int index) const {
  // @@protoc_insertion_point(field_get:collector.HostID.macAddresses)
  return _internal_macaddresses(index);
}
inline std::string* HostID::mutable_macaddresses(int index) {
  // @@protoc_insertion_point(field_mutable:collector.HostID.macAddresses)
  return _impl_.macaddresses_.Mutable(index);
}
inline void HostID::set_macaddresses(int index, const std::string& value) {
  _impl_.macaddresses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:collector.HostID.macAddresses)
}
inline void HostID::set_macaddresses(int index, std::string&& value) {
  _impl_.macaddresses_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:collector.HostID.macAddresses)
}
inline void HostID::set_macaddresses(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.macaddresses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:collector.HostID.macAddresses)
}
inline void HostID::set_macaddresses(int index, const char* value, size_t size) {
  _impl_.macaddresses_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:collector.HostID.macAddresses)
}
inline std::string* HostID::_internal_add_macaddresses() {
  return _impl_.macaddresses_.Add();
}
inline void HostID::add_macaddresses(const std::string& value) {
  _impl_.macaddresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:collector.HostID.macAddresses)
}
inline void HostID::add_macaddresses(std::string&& value) {
  _impl_.macaddresses_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:collector.HostID.macAddresses)
}
inline void HostID::add_macaddresses(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.macaddresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:collector.HostID.macAddresses)
}
inline void HostID::add_macaddresses(const char* value, size_t size) {
  _impl_.macaddresses_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:collector.HostID.macAddresses)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
HostID::macaddresses() const {
  // @@protoc_insertion_point(field_list:collector.HostID.macAddresses)
  return _impl_.macaddresses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
HostID::mutable_macaddresses() {
  // @@protoc_insertion_point(field_mutable_list:collector.HostID.macAddresses)
  return &_impl_.macaddresses_;
}

// string herokuDynoID = 9;
inline void HostID::clear_herokudynoid() {
  _impl_.herokudynoid_.ClearToEmpty();
}
inline const std::string& HostID::herokudynoid() const {
  // @@protoc_insertion_point(field_get:collector.HostID.herokuDynoID)
  return _internal_herokudynoid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HostID::set_herokudynoid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.herokudynoid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.HostID.herokuDynoID)
}
inline std::string* HostID::mutable_herokudynoid() {
  std::string* _s = _internal_mutable_herokudynoid();
  // @@protoc_insertion_point(field_mutable:collector.HostID.herokuDynoID)
  return _s;
}
inline const std::string& HostID::_internal_herokudynoid() const {
  return _impl_.herokudynoid_.Get();
}
inline void HostID::_internal_set_herokudynoid(const std::string& value) {
  
  _impl_.herokudynoid_.Set(value, GetArenaForAllocation());
}
inline std::string* HostID::_internal_mutable_herokudynoid() {
  
  return _impl_.herokudynoid_.Mutable(GetArenaForAllocation());
}
inline std::string* HostID::release_herokudynoid() {
  // @@protoc_insertion_point(field_release:collector.HostID.herokuDynoID)
  return _impl_.herokudynoid_.Release();
}
inline void HostID::set_allocated_herokudynoid(std::string* herokudynoid) {
  if (herokudynoid != nullptr) {
    
  } else {
    
  }
  _impl_.herokudynoid_.SetAllocated(herokudynoid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.herokudynoid_.IsDefault()) {
    _impl_.herokudynoid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.HostID.herokuDynoID)
}

// string azAppServiceInstanceID = 10;
inline void HostID::clear_azappserviceinstanceid() {
  _impl_.azappserviceinstanceid_.ClearToEmpty();
}
inline const std::string& HostID::azappserviceinstanceid() const {
  // @@protoc_insertion_point(field_get:collector.HostID.azAppServiceInstanceID)
  return _internal_azappserviceinstanceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HostID::set_azappserviceinstanceid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.azappserviceinstanceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.HostID.azAppServiceInstanceID)
}
inline std::string* HostID::mutable_azappserviceinstanceid() {
  std::string* _s = _internal_mutable_azappserviceinstanceid();
  // @@protoc_insertion_point(field_mutable:collector.HostID.azAppServiceInstanceID)
  return _s;
}
inline const std::string& HostID::_internal_azappserviceinstanceid() const {
  return _impl_.azappserviceinstanceid_.Get();
}
inline void HostID::_internal_set_azappserviceinstanceid(const std::string& value) {
  
  _impl_.azappserviceinstanceid_.Set(value, GetArenaForAllocation());
}
inline std::string* HostID::_internal_mutable_azappserviceinstanceid() {
  
  return _impl_.azappserviceinstanceid_.Mutable(GetArenaForAllocation());
}
inline std::string* HostID::release_azappserviceinstanceid() {
  // @@protoc_insertion_point(field_release:collector.HostID.azAppServiceInstanceID)
  return _impl_.azappserviceinstanceid_.Release();
}
inline void HostID::set_allocated_azappserviceinstanceid(std::string* azappserviceinstanceid) {
  if (azappserviceinstanceid != nullptr) {
    
  } else {
    
  }
  _impl_.azappserviceinstanceid_.SetAllocated(azappserviceinstanceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.azappserviceinstanceid_.IsDefault()) {
    _impl_.azappserviceinstanceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.HostID.azAppServiceInstanceID)
}

// .collector.HostType hostType = 11;
inline void HostID::clear_hosttype() {
  _impl_.hosttype_ = 0;
}
inline ::collector::HostType HostID::_internal_hosttype() const {
  return static_cast< ::collector::HostType >(_impl_.hosttype_);
}
inline ::collector::HostType HostID::hosttype() const {
  // @@protoc_insertion_point(field_get:collector.HostID.hostType)
  return _internal_hosttype();
}
inline void HostID::_internal_set_hosttype(::collector::HostType value) {
  
  _impl_.hosttype_ = value;
}
inline void HostID::set_hosttype(::collector::HostType value) {
  _internal_set_hosttype(value);
  // @@protoc_insertion_point(field_set:collector.HostID.hostType)
}

// string uamsClientID = 12;
inline void HostID::clear_uamsclientid() {
  _impl_.uamsclientid_.ClearToEmpty();
}
inline const std::string& HostID::uamsclientid() const {
  // @@protoc_insertion_point(field_get:collector.HostID.uamsClientID)
  return _internal_uamsclientid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HostID::set_uamsclientid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uamsclientid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.HostID.uamsClientID)
}
inline std::string* HostID::mutable_uamsclientid() {
  std::string* _s = _internal_mutable_uamsclientid();
  // @@protoc_insertion_point(field_mutable:collector.HostID.uamsClientID)
  return _s;
}
inline const std::string& HostID::_internal_uamsclientid() const {
  return _impl_.uamsclientid_.Get();
}
inline void HostID::_internal_set_uamsclientid(const std::string& value) {
  
  _impl_.uamsclientid_.Set(value, GetArenaForAllocation());
}
inline std::string* HostID::_internal_mutable_uamsclientid() {
  
  return _impl_.uamsclientid_.Mutable(GetArenaForAllocation());
}
inline std::string* HostID::release_uamsclientid() {
  // @@protoc_insertion_point(field_release:collector.HostID.uamsClientID)
  return _impl_.uamsclientid_.Release();
}
inline void HostID::set_allocated_uamsclientid(std::string* uamsclientid) {
  if (uamsclientid != nullptr) {
    
  } else {
    
  }
  _impl_.uamsclientid_.SetAllocated(uamsclientid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uamsclientid_.IsDefault()) {
    _impl_.uamsclientid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.HostID.uamsClientID)
}

// .collector.Aws awsMetadata = 13;
inline bool HostID::_internal_has_awsmetadata() const {
  return this != internal_default_instance() && _impl_.awsmetadata_ != nullptr;
}
inline bool HostID::has_awsmetadata() const {
  return _internal_has_awsmetadata();
}
inline void HostID::clear_awsmetadata() {
  if (GetArenaForAllocation() == nullptr && _impl_.awsmetadata_ != nullptr) {
    delete _impl_.awsmetadata_;
  }
  _impl_.awsmetadata_ = nullptr;
}
inline const ::collector::Aws& HostID::_internal_awsmetadata() const {
  const ::collector::Aws* p = _impl_.awsmetadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::collector::Aws&>(
      ::collector::_Aws_default_instance_);
}
inline const ::collector::Aws& HostID::awsmetadata() const {
  // @@protoc_insertion_point(field_get:collector.HostID.awsMetadata)
  return _internal_awsmetadata();
}
inline void HostID::unsafe_arena_set_allocated_awsmetadata(
    ::collector::Aws* awsmetadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.awsmetadata_);
  }
  _impl_.awsmetadata_ = awsmetadata;
  if (awsmetadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:collector.HostID.awsMetadata)
}
inline ::collector::Aws* HostID::release_awsmetadata() {
  
  ::collector::Aws* temp = _impl_.awsmetadata_;
  _impl_.awsmetadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::collector::Aws* HostID::unsafe_arena_release_awsmetadata() {
  // @@protoc_insertion_point(field_release:collector.HostID.awsMetadata)
  
  ::collector::Aws* temp = _impl_.awsmetadata_;
  _impl_.awsmetadata_ = nullptr;
  return temp;
}
inline ::collector::Aws* HostID::_internal_mutable_awsmetadata() {
  
  if (_impl_.awsmetadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::collector::Aws>(GetArenaForAllocation());
    _impl_.awsmetadata_ = p;
  }
  return _impl_.awsmetadata_;
}
inline ::collector::Aws* HostID::mutable_awsmetadata() {
  ::collector::Aws* _msg = _internal_mutable_awsmetadata();
  // @@protoc_insertion_point(field_mutable:collector.HostID.awsMetadata)
  return _msg;
}
inline void HostID::set_allocated_awsmetadata(::collector::Aws* awsmetadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.awsmetadata_;
  }
  if (awsmetadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(awsmetadata);
    if (message_arena != submessage_arena) {
      awsmetadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, awsmetadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.awsmetadata_ = awsmetadata;
  // @@protoc_insertion_point(field_set_allocated:collector.HostID.awsMetadata)
}

// .collector.Azure azureMetadata = 14;
inline bool HostID::_internal_has_azuremetadata() const {
  return this != internal_default_instance() && _impl_.azuremetadata_ != nullptr;
}
inline bool HostID::has_azuremetadata() const {
  return _internal_has_azuremetadata();
}
inline void HostID::clear_azuremetadata() {
  if (GetArenaForAllocation() == nullptr && _impl_.azuremetadata_ != nullptr) {
    delete _impl_.azuremetadata_;
  }
  _impl_.azuremetadata_ = nullptr;
}
inline const ::collector::Azure& HostID::_internal_azuremetadata() const {
  const ::collector::Azure* p = _impl_.azuremetadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::collector::Azure&>(
      ::collector::_Azure_default_instance_);
}
inline const ::collector::Azure& HostID::azuremetadata() const {
  // @@protoc_insertion_point(field_get:collector.HostID.azureMetadata)
  return _internal_azuremetadata();
}
inline void HostID::unsafe_arena_set_allocated_azuremetadata(
    ::collector::Azure* azuremetadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.azuremetadata_);
  }
  _impl_.azuremetadata_ = azuremetadata;
  if (azuremetadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:collector.HostID.azureMetadata)
}
inline ::collector::Azure* HostID::release_azuremetadata() {
  
  ::collector::Azure* temp = _impl_.azuremetadata_;
  _impl_.azuremetadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::collector::Azure* HostID::unsafe_arena_release_azuremetadata() {
  // @@protoc_insertion_point(field_release:collector.HostID.azureMetadata)
  
  ::collector::Azure* temp = _impl_.azuremetadata_;
  _impl_.azuremetadata_ = nullptr;
  return temp;
}
inline ::collector::Azure* HostID::_internal_mutable_azuremetadata() {
  
  if (_impl_.azuremetadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::collector::Azure>(GetArenaForAllocation());
    _impl_.azuremetadata_ = p;
  }
  return _impl_.azuremetadata_;
}
inline ::collector::Azure* HostID::mutable_azuremetadata() {
  ::collector::Azure* _msg = _internal_mutable_azuremetadata();
  // @@protoc_insertion_point(field_mutable:collector.HostID.azureMetadata)
  return _msg;
}
inline void HostID::set_allocated_azuremetadata(::collector::Azure* azuremetadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.azuremetadata_;
  }
  if (azuremetadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(azuremetadata);
    if (message_arena != submessage_arena) {
      azuremetadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, azuremetadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.azuremetadata_ = azuremetadata;
  // @@protoc_insertion_point(field_set_allocated:collector.HostID.azureMetadata)
}

// .collector.K8s k8sMetadata = 15;
inline bool HostID::_internal_has_k8smetadata() const {
  return this != internal_default_instance() && _impl_.k8smetadata_ != nullptr;
}
inline bool HostID::has_k8smetadata() const {
  return _internal_has_k8smetadata();
}
inline void HostID::clear_k8smetadata() {
  if (GetArenaForAllocation() == nullptr && _impl_.k8smetadata_ != nullptr) {
    delete _impl_.k8smetadata_;
  }
  _impl_.k8smetadata_ = nullptr;
}
inline const ::collector::K8s& HostID::_internal_k8smetadata() const {
  const ::collector::K8s* p = _impl_.k8smetadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::collector::K8s&>(
      ::collector::_K8s_default_instance_);
}
inline const ::collector::K8s& HostID::k8smetadata() const {
  // @@protoc_insertion_point(field_get:collector.HostID.k8sMetadata)
  return _internal_k8smetadata();
}
inline void HostID::unsafe_arena_set_allocated_k8smetadata(
    ::collector::K8s* k8smetadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.k8smetadata_);
  }
  _impl_.k8smetadata_ = k8smetadata;
  if (k8smetadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:collector.HostID.k8sMetadata)
}
inline ::collector::K8s* HostID::release_k8smetadata() {
  
  ::collector::K8s* temp = _impl_.k8smetadata_;
  _impl_.k8smetadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::collector::K8s* HostID::unsafe_arena_release_k8smetadata() {
  // @@protoc_insertion_point(field_release:collector.HostID.k8sMetadata)
  
  ::collector::K8s* temp = _impl_.k8smetadata_;
  _impl_.k8smetadata_ = nullptr;
  return temp;
}
inline ::collector::K8s* HostID::_internal_mutable_k8smetadata() {
  
  if (_impl_.k8smetadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::collector::K8s>(GetArenaForAllocation());
    _impl_.k8smetadata_ = p;
  }
  return _impl_.k8smetadata_;
}
inline ::collector::K8s* HostID::mutable_k8smetadata() {
  ::collector::K8s* _msg = _internal_mutable_k8smetadata();
  // @@protoc_insertion_point(field_mutable:collector.HostID.k8sMetadata)
  return _msg;
}
inline void HostID::set_allocated_k8smetadata(::collector::K8s* k8smetadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.k8smetadata_;
  }
  if (k8smetadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(k8smetadata);
    if (message_arena != submessage_arena) {
      k8smetadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, k8smetadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.k8smetadata_ = k8smetadata;
  // @@protoc_insertion_point(field_set_allocated:collector.HostID.k8sMetadata)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// OboeSetting

// .collector.OboeSettingType type = 1;
inline void OboeSetting::clear_type() {
  _impl_.type_ = 0;
}
inline ::collector::OboeSettingType OboeSetting::_internal_type() const {
  return static_cast< ::collector::OboeSettingType >(_impl_.type_);
}
inline ::collector::OboeSettingType OboeSetting::type() const {
  // @@protoc_insertion_point(field_get:collector.OboeSetting.type)
  return _internal_type();
}
inline void OboeSetting::_internal_set_type(::collector::OboeSettingType value) {
  
  _impl_.type_ = value;
}
inline void OboeSetting::set_type(::collector::OboeSettingType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:collector.OboeSetting.type)
}

// bytes flags = 2;
inline void OboeSetting::clear_flags() {
  _impl_.flags_.ClearToEmpty();
}
inline const std::string& OboeSetting::flags() const {
  // @@protoc_insertion_point(field_get:collector.OboeSetting.flags)
  return _internal_flags();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OboeSetting::set_flags(ArgT0&& arg0, ArgT... args) {
 
 _impl_.flags_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.OboeSetting.flags)
}
inline std::string* OboeSetting::mutable_flags() {
  std::string* _s = _internal_mutable_flags();
  // @@protoc_insertion_point(field_mutable:collector.OboeSetting.flags)
  return _s;
}
inline const std::string& OboeSetting::_internal_flags() const {
  return _impl_.flags_.Get();
}
inline void OboeSetting::_internal_set_flags(const std::string& value) {
  
  _impl_.flags_.Set(value, GetArenaForAllocation());
}
inline std::string* OboeSetting::_internal_mutable_flags() {
  
  return _impl_.flags_.Mutable(GetArenaForAllocation());
}
inline std::string* OboeSetting::release_flags() {
  // @@protoc_insertion_point(field_release:collector.OboeSetting.flags)
  return _impl_.flags_.Release();
}
inline void OboeSetting::set_allocated_flags(std::string* flags) {
  if (flags != nullptr) {
    
  } else {
    
  }
  _impl_.flags_.SetAllocated(flags, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.flags_.IsDefault()) {
    _impl_.flags_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.OboeSetting.flags)
}

// int64 timestamp = 3;
inline void OboeSetting::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t OboeSetting::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t OboeSetting::timestamp() const {
  // @@protoc_insertion_point(field_get:collector.OboeSetting.timestamp)
  return _internal_timestamp();
}
inline void OboeSetting::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void OboeSetting::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:collector.OboeSetting.timestamp)
}

// int64 value = 4;
inline void OboeSetting::clear_value() {
  _impl_.value_ = int64_t{0};
}
inline int64_t OboeSetting::_internal_value() const {
  return _impl_.value_;
}
inline int64_t OboeSetting::value() const {
  // @@protoc_insertion_point(field_get:collector.OboeSetting.value)
  return _internal_value();
}
inline void OboeSetting::_internal_set_value(int64_t value) {
  
  _impl_.value_ = value;
}
inline void OboeSetting::set_value(int64_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:collector.OboeSetting.value)
}

// bytes layer = 5;
inline void OboeSetting::clear_layer() {
  _impl_.layer_.ClearToEmpty();
}
inline const std::string& OboeSetting::layer() const {
  // @@protoc_insertion_point(field_get:collector.OboeSetting.layer)
  return _internal_layer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OboeSetting::set_layer(ArgT0&& arg0, ArgT... args) {
 
 _impl_.layer_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.OboeSetting.layer)
}
inline std::string* OboeSetting::mutable_layer() {
  std::string* _s = _internal_mutable_layer();
  // @@protoc_insertion_point(field_mutable:collector.OboeSetting.layer)
  return _s;
}
inline const std::string& OboeSetting::_internal_layer() const {
  return _impl_.layer_.Get();
}
inline void OboeSetting::_internal_set_layer(const std::string& value) {
  
  _impl_.layer_.Set(value, GetArenaForAllocation());
}
inline std::string* OboeSetting::_internal_mutable_layer() {
  
  return _impl_.layer_.Mutable(GetArenaForAllocation());
}
inline std::string* OboeSetting::release_layer() {
  // @@protoc_insertion_point(field_release:collector.OboeSetting.layer)
  return _impl_.layer_.Release();
}
inline void OboeSetting::set_allocated_layer(std::string* layer) {
  if (layer != nullptr) {
    
  } else {
    
  }
  _impl_.layer_.SetAllocated(layer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.layer_.IsDefault()) {
    _impl_.layer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.OboeSetting.layer)
}

// map<string, bytes> arguments = 7;
inline int OboeSetting::_internal_arguments_size() const {
  return _impl_.arguments_.size();
}
inline int OboeSetting::arguments_size() const {
  return _internal_arguments_size();
}
inline void OboeSetting::clear_arguments() {
  _impl_.arguments_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
OboeSetting::_internal_arguments() const {
  return _impl_.arguments_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
OboeSetting::arguments() const {
  // @@protoc_insertion_point(field_map:collector.OboeSetting.arguments)
  return _internal_arguments();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
OboeSetting::_internal_mutable_arguments() {
  return _impl_.arguments_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
OboeSetting::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_map:collector.OboeSetting.arguments)
  return _internal_mutable_arguments();
}

// int64 ttl = 8;
inline void OboeSetting::clear_ttl() {
  _impl_.ttl_ = int64_t{0};
}
inline int64_t OboeSetting::_internal_ttl() const {
  return _impl_.ttl_;
}
inline int64_t OboeSetting::ttl() const {
  // @@protoc_insertion_point(field_get:collector.OboeSetting.ttl)
  return _internal_ttl();
}
inline void OboeSetting::_internal_set_ttl(int64_t value) {
  
  _impl_.ttl_ = value;
}
inline void OboeSetting::set_ttl(int64_t value) {
  _internal_set_ttl(value);
  // @@protoc_insertion_point(field_set:collector.OboeSetting.ttl)
}

// -------------------------------------------------------------------

// MessageRequest

// string api_key = 1;
inline void MessageRequest::clear_api_key() {
  _impl_.api_key_.ClearToEmpty();
}
inline const std::string& MessageRequest::api_key() const {
  // @@protoc_insertion_point(field_get:collector.MessageRequest.api_key)
  return _internal_api_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessageRequest::set_api_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.api_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.MessageRequest.api_key)
}
inline std::string* MessageRequest::mutable_api_key() {
  std::string* _s = _internal_mutable_api_key();
  // @@protoc_insertion_point(field_mutable:collector.MessageRequest.api_key)
  return _s;
}
inline const std::string& MessageRequest::_internal_api_key() const {
  return _impl_.api_key_.Get();
}
inline void MessageRequest::_internal_set_api_key(const std::string& value) {
  
  _impl_.api_key_.Set(value, GetArenaForAllocation());
}
inline std::string* MessageRequest::_internal_mutable_api_key() {
  
  return _impl_.api_key_.Mutable(GetArenaForAllocation());
}
inline std::string* MessageRequest::release_api_key() {
  // @@protoc_insertion_point(field_release:collector.MessageRequest.api_key)
  return _impl_.api_key_.Release();
}
inline void MessageRequest::set_allocated_api_key(std::string* api_key) {
  if (api_key != nullptr) {
    
  } else {
    
  }
  _impl_.api_key_.SetAllocated(api_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.api_key_.IsDefault()) {
    _impl_.api_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.MessageRequest.api_key)
}

// repeated bytes messages = 2;
inline int MessageRequest::_internal_messages_size() const {
  return _impl_.messages_.size();
}
inline int MessageRequest::messages_size() const {
  return _internal_messages_size();
}
inline void MessageRequest::clear_messages() {
  _impl_.messages_.Clear();
}
inline std::string* MessageRequest::add_messages() {
  std::string* _s = _internal_add_messages();
  // @@protoc_insertion_point(field_add_mutable:collector.MessageRequest.messages)
  return _s;
}
inline const std::string& MessageRequest::_internal_messages(int index) const {
  return _impl_.messages_.Get(index);
}
inline const std::string& MessageRequest::messages(int index) const {
  // @@protoc_insertion_point(field_get:collector.MessageRequest.messages)
  return _internal_messages(index);
}
inline std::string* MessageRequest::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:collector.MessageRequest.messages)
  return _impl_.messages_.Mutable(index);
}
inline void MessageRequest::set_messages(int index, const std::string& value) {
  _impl_.messages_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:collector.MessageRequest.messages)
}
inline void MessageRequest::set_messages(int index, std::string&& value) {
  _impl_.messages_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:collector.MessageRequest.messages)
}
inline void MessageRequest::set_messages(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.messages_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:collector.MessageRequest.messages)
}
inline void MessageRequest::set_messages(int index, const void* value, size_t size) {
  _impl_.messages_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:collector.MessageRequest.messages)
}
inline std::string* MessageRequest::_internal_add_messages() {
  return _impl_.messages_.Add();
}
inline void MessageRequest::add_messages(const std::string& value) {
  _impl_.messages_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:collector.MessageRequest.messages)
}
inline void MessageRequest::add_messages(std::string&& value) {
  _impl_.messages_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:collector.MessageRequest.messages)
}
inline void MessageRequest::add_messages(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.messages_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:collector.MessageRequest.messages)
}
inline void MessageRequest::add_messages(const void* value, size_t size) {
  _impl_.messages_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:collector.MessageRequest.messages)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MessageRequest::messages() const {
  // @@protoc_insertion_point(field_list:collector.MessageRequest.messages)
  return _impl_.messages_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MessageRequest::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:collector.MessageRequest.messages)
  return &_impl_.messages_;
}

// .collector.EncodingType encoding = 3;
inline void MessageRequest::clear_encoding() {
  _impl_.encoding_ = 0;
}
inline ::collector::EncodingType MessageRequest::_internal_encoding() const {
  return static_cast< ::collector::EncodingType >(_impl_.encoding_);
}
inline ::collector::EncodingType MessageRequest::encoding() const {
  // @@protoc_insertion_point(field_get:collector.MessageRequest.encoding)
  return _internal_encoding();
}
inline void MessageRequest::_internal_set_encoding(::collector::EncodingType value) {
  
  _impl_.encoding_ = value;
}
inline void MessageRequest::set_encoding(::collector::EncodingType value) {
  _internal_set_encoding(value);
  // @@protoc_insertion_point(field_set:collector.MessageRequest.encoding)
}

// .collector.HostID identity = 4;
inline bool MessageRequest::_internal_has_identity() const {
  return this != internal_default_instance() && _impl_.identity_ != nullptr;
}
inline bool MessageRequest::has_identity() const {
  return _internal_has_identity();
}
inline void MessageRequest::clear_identity() {
  if (GetArenaForAllocation() == nullptr && _impl_.identity_ != nullptr) {
    delete _impl_.identity_;
  }
  _impl_.identity_ = nullptr;
}
inline const ::collector::HostID& MessageRequest::_internal_identity() const {
  const ::collector::HostID* p = _impl_.identity_;
  return p != nullptr ? *p : reinterpret_cast<const ::collector::HostID&>(
      ::collector::_HostID_default_instance_);
}
inline const ::collector::HostID& MessageRequest::identity() const {
  // @@protoc_insertion_point(field_get:collector.MessageRequest.identity)
  return _internal_identity();
}
inline void MessageRequest::unsafe_arena_set_allocated_identity(
    ::collector::HostID* identity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.identity_);
  }
  _impl_.identity_ = identity;
  if (identity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:collector.MessageRequest.identity)
}
inline ::collector::HostID* MessageRequest::release_identity() {
  
  ::collector::HostID* temp = _impl_.identity_;
  _impl_.identity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::collector::HostID* MessageRequest::unsafe_arena_release_identity() {
  // @@protoc_insertion_point(field_release:collector.MessageRequest.identity)
  
  ::collector::HostID* temp = _impl_.identity_;
  _impl_.identity_ = nullptr;
  return temp;
}
inline ::collector::HostID* MessageRequest::_internal_mutable_identity() {
  
  if (_impl_.identity_ == nullptr) {
    auto* p = CreateMaybeMessage<::collector::HostID>(GetArenaForAllocation());
    _impl_.identity_ = p;
  }
  return _impl_.identity_;
}
inline ::collector::HostID* MessageRequest::mutable_identity() {
  ::collector::HostID* _msg = _internal_mutable_identity();
  // @@protoc_insertion_point(field_mutable:collector.MessageRequest.identity)
  return _msg;
}
inline void MessageRequest::set_allocated_identity(::collector::HostID* identity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.identity_;
  }
  if (identity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(identity);
    if (message_arena != submessage_arena) {
      identity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, identity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.identity_ = identity;
  // @@protoc_insertion_point(field_set_allocated:collector.MessageRequest.identity)
}

// -------------------------------------------------------------------

// MessageResult

// .collector.ResultCode result = 1;
inline void MessageResult::clear_result() {
  _impl_.result_ = 0;
}
inline ::collector::ResultCode MessageResult::_internal_result() const {
  return static_cast< ::collector::ResultCode >(_impl_.result_);
}
inline ::collector::ResultCode MessageResult::result() const {
  // @@protoc_insertion_point(field_get:collector.MessageResult.result)
  return _internal_result();
}
inline void MessageResult::_internal_set_result(::collector::ResultCode value) {
  
  _impl_.result_ = value;
}
inline void MessageResult::set_result(::collector::ResultCode value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:collector.MessageResult.result)
}

// string arg = 2;
inline void MessageResult::clear_arg() {
  _impl_.arg_.ClearToEmpty();
}
inline const std::string& MessageResult::arg() const {
  // @@protoc_insertion_point(field_get:collector.MessageResult.arg)
  return _internal_arg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessageResult::set_arg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.arg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.MessageResult.arg)
}
inline std::string* MessageResult::mutable_arg() {
  std::string* _s = _internal_mutable_arg();
  // @@protoc_insertion_point(field_mutable:collector.MessageResult.arg)
  return _s;
}
inline const std::string& MessageResult::_internal_arg() const {
  return _impl_.arg_.Get();
}
inline void MessageResult::_internal_set_arg(const std::string& value) {
  
  _impl_.arg_.Set(value, GetArenaForAllocation());
}
inline std::string* MessageResult::_internal_mutable_arg() {
  
  return _impl_.arg_.Mutable(GetArenaForAllocation());
}
inline std::string* MessageResult::release_arg() {
  // @@protoc_insertion_point(field_release:collector.MessageResult.arg)
  return _impl_.arg_.Release();
}
inline void MessageResult::set_allocated_arg(std::string* arg) {
  if (arg != nullptr) {
    
  } else {
    
  }
  _impl_.arg_.SetAllocated(arg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.arg_.IsDefault()) {
    _impl_.arg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.MessageResult.arg)
}

// string warning = 4;
inline void MessageResult::clear_warning() {
  _impl_.warning_.ClearToEmpty();
}
inline const std::string& MessageResult::warning() const {
  // @@protoc_insertion_point(field_get:collector.MessageResult.warning)
  return _internal_warning();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessageResult::set_warning(ArgT0&& arg0, ArgT... args) {
 
 _impl_.warning_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.MessageResult.warning)
}
inline std::string* MessageResult::mutable_warning() {
  std::string* _s = _internal_mutable_warning();
  // @@protoc_insertion_point(field_mutable:collector.MessageResult.warning)
  return _s;
}
inline const std::string& MessageResult::_internal_warning() const {
  return _impl_.warning_.Get();
}
inline void MessageResult::_internal_set_warning(const std::string& value) {
  
  _impl_.warning_.Set(value, GetArenaForAllocation());
}
inline std::string* MessageResult::_internal_mutable_warning() {
  
  return _impl_.warning_.Mutable(GetArenaForAllocation());
}
inline std::string* MessageResult::release_warning() {
  // @@protoc_insertion_point(field_release:collector.MessageResult.warning)
  return _impl_.warning_.Release();
}
inline void MessageResult::set_allocated_warning(std::string* warning) {
  if (warning != nullptr) {
    
  } else {
    
  }
  _impl_.warning_.SetAllocated(warning, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.warning_.IsDefault()) {
    _impl_.warning_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.MessageResult.warning)
}

// -------------------------------------------------------------------

// SettingsRequest

// string api_key = 1;
inline void SettingsRequest::clear_api_key() {
  _impl_.api_key_.ClearToEmpty();
}
inline const std::string& SettingsRequest::api_key() const {
  // @@protoc_insertion_point(field_get:collector.SettingsRequest.api_key)
  return _internal_api_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SettingsRequest::set_api_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.api_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.SettingsRequest.api_key)
}
inline std::string* SettingsRequest::mutable_api_key() {
  std::string* _s = _internal_mutable_api_key();
  // @@protoc_insertion_point(field_mutable:collector.SettingsRequest.api_key)
  return _s;
}
inline const std::string& SettingsRequest::_internal_api_key() const {
  return _impl_.api_key_.Get();
}
inline void SettingsRequest::_internal_set_api_key(const std::string& value) {
  
  _impl_.api_key_.Set(value, GetArenaForAllocation());
}
inline std::string* SettingsRequest::_internal_mutable_api_key() {
  
  return _impl_.api_key_.Mutable(GetArenaForAllocation());
}
inline std::string* SettingsRequest::release_api_key() {
  // @@protoc_insertion_point(field_release:collector.SettingsRequest.api_key)
  return _impl_.api_key_.Release();
}
inline void SettingsRequest::set_allocated_api_key(std::string* api_key) {
  if (api_key != nullptr) {
    
  } else {
    
  }
  _impl_.api_key_.SetAllocated(api_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.api_key_.IsDefault()) {
    _impl_.api_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.SettingsRequest.api_key)
}

// .collector.HostID identity = 2;
inline bool SettingsRequest::_internal_has_identity() const {
  return this != internal_default_instance() && _impl_.identity_ != nullptr;
}
inline bool SettingsRequest::has_identity() const {
  return _internal_has_identity();
}
inline void SettingsRequest::clear_identity() {
  if (GetArenaForAllocation() == nullptr && _impl_.identity_ != nullptr) {
    delete _impl_.identity_;
  }
  _impl_.identity_ = nullptr;
}
inline const ::collector::HostID& SettingsRequest::_internal_identity() const {
  const ::collector::HostID* p = _impl_.identity_;
  return p != nullptr ? *p : reinterpret_cast<const ::collector::HostID&>(
      ::collector::_HostID_default_instance_);
}
inline const ::collector::HostID& SettingsRequest::identity() const {
  // @@protoc_insertion_point(field_get:collector.SettingsRequest.identity)
  return _internal_identity();
}
inline void SettingsRequest::unsafe_arena_set_allocated_identity(
    ::collector::HostID* identity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.identity_);
  }
  _impl_.identity_ = identity;
  if (identity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:collector.SettingsRequest.identity)
}
inline ::collector::HostID* SettingsRequest::release_identity() {
  
  ::collector::HostID* temp = _impl_.identity_;
  _impl_.identity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::collector::HostID* SettingsRequest::unsafe_arena_release_identity() {
  // @@protoc_insertion_point(field_release:collector.SettingsRequest.identity)
  
  ::collector::HostID* temp = _impl_.identity_;
  _impl_.identity_ = nullptr;
  return temp;
}
inline ::collector::HostID* SettingsRequest::_internal_mutable_identity() {
  
  if (_impl_.identity_ == nullptr) {
    auto* p = CreateMaybeMessage<::collector::HostID>(GetArenaForAllocation());
    _impl_.identity_ = p;
  }
  return _impl_.identity_;
}
inline ::collector::HostID* SettingsRequest::mutable_identity() {
  ::collector::HostID* _msg = _internal_mutable_identity();
  // @@protoc_insertion_point(field_mutable:collector.SettingsRequest.identity)
  return _msg;
}
inline void SettingsRequest::set_allocated_identity(::collector::HostID* identity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.identity_;
  }
  if (identity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(identity);
    if (message_arena != submessage_arena) {
      identity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, identity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.identity_ = identity;
  // @@protoc_insertion_point(field_set_allocated:collector.SettingsRequest.identity)
}

// string clientVersion = 3;
inline void SettingsRequest::clear_clientversion() {
  _impl_.clientversion_.ClearToEmpty();
}
inline const std::string& SettingsRequest::clientversion() const {
  // @@protoc_insertion_point(field_get:collector.SettingsRequest.clientVersion)
  return _internal_clientversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SettingsRequest::set_clientversion(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientversion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.SettingsRequest.clientVersion)
}
inline std::string* SettingsRequest::mutable_clientversion() {
  std::string* _s = _internal_mutable_clientversion();
  // @@protoc_insertion_point(field_mutable:collector.SettingsRequest.clientVersion)
  return _s;
}
inline const std::string& SettingsRequest::_internal_clientversion() const {
  return _impl_.clientversion_.Get();
}
inline void SettingsRequest::_internal_set_clientversion(const std::string& value) {
  
  _impl_.clientversion_.Set(value, GetArenaForAllocation());
}
inline std::string* SettingsRequest::_internal_mutable_clientversion() {
  
  return _impl_.clientversion_.Mutable(GetArenaForAllocation());
}
inline std::string* SettingsRequest::release_clientversion() {
  // @@protoc_insertion_point(field_release:collector.SettingsRequest.clientVersion)
  return _impl_.clientversion_.Release();
}
inline void SettingsRequest::set_allocated_clientversion(std::string* clientversion) {
  if (clientversion != nullptr) {
    
  } else {
    
  }
  _impl_.clientversion_.SetAllocated(clientversion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientversion_.IsDefault()) {
    _impl_.clientversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.SettingsRequest.clientVersion)
}

// -------------------------------------------------------------------

// SettingsResult

// .collector.ResultCode result = 1;
inline void SettingsResult::clear_result() {
  _impl_.result_ = 0;
}
inline ::collector::ResultCode SettingsResult::_internal_result() const {
  return static_cast< ::collector::ResultCode >(_impl_.result_);
}
inline ::collector::ResultCode SettingsResult::result() const {
  // @@protoc_insertion_point(field_get:collector.SettingsResult.result)
  return _internal_result();
}
inline void SettingsResult::_internal_set_result(::collector::ResultCode value) {
  
  _impl_.result_ = value;
}
inline void SettingsResult::set_result(::collector::ResultCode value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:collector.SettingsResult.result)
}

// string arg = 2;
inline void SettingsResult::clear_arg() {
  _impl_.arg_.ClearToEmpty();
}
inline const std::string& SettingsResult::arg() const {
  // @@protoc_insertion_point(field_get:collector.SettingsResult.arg)
  return _internal_arg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SettingsResult::set_arg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.arg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.SettingsResult.arg)
}
inline std::string* SettingsResult::mutable_arg() {
  std::string* _s = _internal_mutable_arg();
  // @@protoc_insertion_point(field_mutable:collector.SettingsResult.arg)
  return _s;
}
inline const std::string& SettingsResult::_internal_arg() const {
  return _impl_.arg_.Get();
}
inline void SettingsResult::_internal_set_arg(const std::string& value) {
  
  _impl_.arg_.Set(value, GetArenaForAllocation());
}
inline std::string* SettingsResult::_internal_mutable_arg() {
  
  return _impl_.arg_.Mutable(GetArenaForAllocation());
}
inline std::string* SettingsResult::release_arg() {
  // @@protoc_insertion_point(field_release:collector.SettingsResult.arg)
  return _impl_.arg_.Release();
}
inline void SettingsResult::set_allocated_arg(std::string* arg) {
  if (arg != nullptr) {
    
  } else {
    
  }
  _impl_.arg_.SetAllocated(arg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.arg_.IsDefault()) {
    _impl_.arg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.SettingsResult.arg)
}

// repeated .collector.OboeSetting settings = 3;
inline int SettingsResult::_internal_settings_size() const {
  return _impl_.settings_.size();
}
inline int SettingsResult::settings_size() const {
  return _internal_settings_size();
}
inline void SettingsResult::clear_settings() {
  _impl_.settings_.Clear();
}
inline ::collector::OboeSetting* SettingsResult::mutable_settings(int index) {
  // @@protoc_insertion_point(field_mutable:collector.SettingsResult.settings)
  return _impl_.settings_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::collector::OboeSetting >*
SettingsResult::mutable_settings() {
  // @@protoc_insertion_point(field_mutable_list:collector.SettingsResult.settings)
  return &_impl_.settings_;
}
inline const ::collector::OboeSetting& SettingsResult::_internal_settings(int index) const {
  return _impl_.settings_.Get(index);
}
inline const ::collector::OboeSetting& SettingsResult::settings(int index) const {
  // @@protoc_insertion_point(field_get:collector.SettingsResult.settings)
  return _internal_settings(index);
}
inline ::collector::OboeSetting* SettingsResult::_internal_add_settings() {
  return _impl_.settings_.Add();
}
inline ::collector::OboeSetting* SettingsResult::add_settings() {
  ::collector::OboeSetting* _add = _internal_add_settings();
  // @@protoc_insertion_point(field_add:collector.SettingsResult.settings)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::collector::OboeSetting >&
SettingsResult::settings() const {
  // @@protoc_insertion_point(field_list:collector.SettingsResult.settings)
  return _impl_.settings_;
}

// string warning = 4;
inline void SettingsResult::clear_warning() {
  _impl_.warning_.ClearToEmpty();
}
inline const std::string& SettingsResult::warning() const {
  // @@protoc_insertion_point(field_get:collector.SettingsResult.warning)
  return _internal_warning();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SettingsResult::set_warning(ArgT0&& arg0, ArgT... args) {
 
 _impl_.warning_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.SettingsResult.warning)
}
inline std::string* SettingsResult::mutable_warning() {
  std::string* _s = _internal_mutable_warning();
  // @@protoc_insertion_point(field_mutable:collector.SettingsResult.warning)
  return _s;
}
inline const std::string& SettingsResult::_internal_warning() const {
  return _impl_.warning_.Get();
}
inline void SettingsResult::_internal_set_warning(const std::string& value) {
  
  _impl_.warning_.Set(value, GetArenaForAllocation());
}
inline std::string* SettingsResult::_internal_mutable_warning() {
  
  return _impl_.warning_.Mutable(GetArenaForAllocation());
}
inline std::string* SettingsResult::release_warning() {
  // @@protoc_insertion_point(field_release:collector.SettingsResult.warning)
  return _impl_.warning_.Release();
}
inline void SettingsResult::set_allocated_warning(std::string* warning) {
  if (warning != nullptr) {
    
  } else {
    
  }
  _impl_.warning_.SetAllocated(warning, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.warning_.IsDefault()) {
    _impl_.warning_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.SettingsResult.warning)
}

// -------------------------------------------------------------------

// PingRequest

// string api_key = 1;
inline void PingRequest::clear_api_key() {
  _impl_.api_key_.ClearToEmpty();
}
inline const std::string& PingRequest::api_key() const {
  // @@protoc_insertion_point(field_get:collector.PingRequest.api_key)
  return _internal_api_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PingRequest::set_api_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.api_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:collector.PingRequest.api_key)
}
inline std::string* PingRequest::mutable_api_key() {
  std::string* _s = _internal_mutable_api_key();
  // @@protoc_insertion_point(field_mutable:collector.PingRequest.api_key)
  return _s;
}
inline const std::string& PingRequest::_internal_api_key() const {
  return _impl_.api_key_.Get();
}
inline void PingRequest::_internal_set_api_key(const std::string& value) {
  
  _impl_.api_key_.Set(value, GetArenaForAllocation());
}
inline std::string* PingRequest::_internal_mutable_api_key() {
  
  return _impl_.api_key_.Mutable(GetArenaForAllocation());
}
inline std::string* PingRequest::release_api_key() {
  // @@protoc_insertion_point(field_release:collector.PingRequest.api_key)
  return _impl_.api_key_.Release();
}
inline void PingRequest::set_allocated_api_key(std::string* api_key) {
  if (api_key != nullptr) {
    
  } else {
    
  }
  _impl_.api_key_.SetAllocated(api_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.api_key_.IsDefault()) {
    _impl_.api_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:collector.PingRequest.api_key)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace collector

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::collector::ResultCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::collector::ResultCode>() {
  return ::collector::ResultCode_descriptor();
}
template <> struct is_proto_enum< ::collector::EncodingType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::collector::EncodingType>() {
  return ::collector::EncodingType_descriptor();
}
template <> struct is_proto_enum< ::collector::HostType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::collector::HostType>() {
  return ::collector::HostType_descriptor();
}
template <> struct is_proto_enum< ::collector::OboeSettingType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::collector::OboeSettingType>() {
  return ::collector::OboeSettingType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_collector_2eproto
